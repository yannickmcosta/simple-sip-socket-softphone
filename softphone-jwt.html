<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket SIP Softphone (JWT Authentication)</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <script src="./sip-0.21.2.js"></script>
    <style>
        :root {
            --status-connected: #28a745;
            --status-disconnected: #dc3545;
            --status-connecting: #ffc107;
        }
        .status-connected { color: var(--status-connected); }
        .status-disconnected { color: var(--status-disconnected); }
        .status-connecting { color: var(--status-connecting); }
        .call-active { background-color: #d4edda; border-color: #c3e6cb; }
        .number-pad {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .number-pad .pad-row {
            display: flex;
            gap: 8px;
        }
        .number-pad button {
            width: 85px;
            height: 85px;
            font-size: 1.75rem;
            font-weight: 500;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            line-height: 1.1;
            padding: 0;
        }
        .number-pad button small {
            font-size: 0.6rem;
            font-weight: 400;
            letter-spacing: 2px;
            margin-top: 2px;
        }
        .volume-control { width: 100%; }
        .call-info { font-family: monospace; }
        #audioContainer audio { width: 100%; margin: 5px 0; }
        .presence-card { transition: all 0.3s ease; }
        .presence-card:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .jwt-token-field { font-family: monospace; font-size: 0.85rem; }

        /* Registration expiry warning styles */
        .reg-expiry-normal { color: inherit; }
        .reg-expiry-warning { color: #e67e22; font-weight: 600; }
        .reg-expiry-danger { color: #dc3545; font-weight: 700; animation: blink 1s infinite; }

        /* Sticky Status Header */
        .status-header {
            position: sticky;
            top: 0;
            z-index: 1020;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            padding: 0.75rem 1rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .status-header.header-disconnected { background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); }
        .status-header.header-connecting { background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%); color: #212529; }
        .status-header.header-connected { background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%); }
        .status-header.header-in-call { background: linear-gradient(135deg, #007bff 0%, #0056b3 100%); }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .status-dot.dot-disconnected { background-color: #fff; box-shadow: 0 0 0 2px #dc3545; }
        .status-dot.dot-connecting { background-color: #212529; animation: blink 1s infinite; }
        .status-dot.dot-connected { background-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.8); }

        .status-header .registration-badge {
            background: rgba(255,255,255,0.2);
            padding: 2px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
        }
        .app-title {
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .app-title i {
            margin-right: 6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Main content area */
        .main-content {
            padding-top: 1rem;
            padding-bottom: 80px;
        }

        /* Dialer styling */
        .dialer-card {
            border: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        .dialer-card .card-body {
            padding: 1.5rem;
        }
        #phoneNumber {
            font-size: 1.5rem;
            text-align: center;
            letter-spacing: 2px;
        }
        #callBtn {
            font-size: 1.25rem;
            padding: 1rem;
        }

        /* Call info card */
        .call-info-card {
            border-left: 4px solid #007bff;
            background: #f8f9fa;
        }
        .call-info-card.on-call {
            border-left-color: #28a745;
            background: #d4edda;
        }
        .custom-headers-card {
            border-left: 4px solid #6f42c1;
            background: #f8f5ff;
            font-family: monospace;
            font-size: 0.85rem;
        }
        .custom-headers-card .header-name {
            color: #6f42c1;
            font-weight: 600;
        }
        .custom-headers-card .header-value {
            color: #333;
            word-break: break-all;
        }

        /* Side panels */
        .side-panel {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
        }

        /* Mobile bottom nav */
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-top: 1px solid #dee2e6;
            padding: 0.5rem;
            z-index: 1030;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        .mobile-bottom-nav .nav-item {
            flex: 1;
            text-align: center;
        }
        .mobile-bottom-nav .nav-link {
            padding: 0.5rem;
            color: #6c757d;
            font-size: 0.75rem;
        }
        .mobile-bottom-nav .nav-link.active {
            color: #007bff;
        }
        .mobile-bottom-nav .nav-link i {
            font-size: 1.25rem;
            display: block;
        }

        @media (max-width: 991.98px) {
            .mobile-bottom-nav { display: flex; }
            .side-panel-col { display: none; }
            .main-content { padding-bottom: 100px; }
        }

        /* Offcanvas panels for mobile */
        .offcanvas-panel {
            max-height: 80vh;
            overflow-y: auto;
        }

        /* Settings offcanvas */
        #settingsOffcanvas {
            width: 450px;
        }
        @media (max-width: 575.98px) {
            #settingsOffcanvas { width: 100%; }
        }

        /* DTMF buttons inline */
        .dtmf-inline .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        /* Quick Dial & Favorites items */
        .quick-dial-item, .favorite-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            border-radius: 6px;
            margin-bottom: 4px;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .quick-dial-item:hover, .favorite-item:hover {
            background: #e9ecef;
        }
        .quick-dial-item .dial-name, .favorite-item .fav-name {
            font-weight: 500;
            font-size: 0.85rem;
        }
        .quick-dial-item .dial-number, .favorite-item .fav-number {
            font-size: 0.75rem;
            color: #6c757d;
        }
        .quick-dial-item .dial-actions, .favorite-item .fav-actions {
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .quick-dial-item:hover .dial-actions, .favorite-item:hover .fav-actions {
            opacity: 1;
        }
        .quick-dial-item .btn-call {
            color: #28a745;
        }
        .quick-dial-item .btn-remove, .favorite-item .btn-remove {
            color: #dc3545;
        }

        /* DND active state */
        .dnd-active {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%) !important;
        }
        .dnd-badge {
            background: #ffc107;
            color: #212529;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
            margin-left: 8px;
        }

        /* Account card styling */
        #accountUser {
            max-width: 120px;
        }
        #accountDomain {
            max-width: 120px;
        }
    </style>
</head>
<body>
    <!-- Sticky Status Header -->
    <header class="status-header header-disconnected" id="statusHeader">
        <div class="container-fluid">
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center">
                    <span class="app-title me-3">
                        <i class="bi bi-telephone-fill"></i>SIP Softphone
                    </span>
                    <span class="status-dot dot-disconnected" id="statusDot"></span>
                    <span id="connectionStatus" class="fw-bold me-2">Disconnected</span>
                    <span id="registrationStatus" class="registration-badge ms-2"></span>
                </div>
                <div class="d-flex align-items-center">
                    <span id="headerCallInfo" class="me-3 d-none">
                        <i class="bi bi-telephone-forward-fill"></i>
                        <span id="headerRemoteParty"></span>
                        <span id="headerCallDuration" class="ms-2 fw-bold"></span>
                    </span>
                    <button class="btn btn-sm btn-outline-light" type="button" data-bs-toggle="offcanvas" data-bs-target="#settingsOffcanvas">
                        <i class="bi bi-gear-fill"></i> Settings
                    </button>
                </div>
            </div>
            <div id="errorMessage" class="small mt-1" style="display: none;"></div>
        </div>
    </header>

    <!-- Settings Offcanvas -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="settingsOffcanvas">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title"><i class="bi bi-gear"></i> Connection Settings</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body">
            <!-- Connection Fields -->
            <div class="mb-3">
                <label for="wsServer" class="form-label">WebSocket Server</label>
                <input type="text" class="form-control" id="wsServer" placeholder="wss://your-server.example.com:8089/ws">
            </div>
            <div class="row mb-3">
                <div class="col-6">
                    <label for="sipUser" class="form-label">SIP User</label>
                    <input type="text" class="form-control" id="sipUser" placeholder="extension">
                </div>
                <div class="col-6">
                    <label for="sipDomain" class="form-label">Domain</label>
                    <input type="text" class="form-control" id="sipDomain" placeholder="example.com">
                </div>
            </div>
            <div class="mb-3">
                <label for="jwtToken" class="form-label">JWT Token <small class="text-muted">(Bearer Auth)</small></label>
                <textarea class="form-control jwt-token-field" id="jwtToken" rows="3" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."></textarea>
            </div>

            <!-- Action Buttons -->
            <div class="d-flex flex-wrap gap-2 mb-4">
                <input type="file" id="configFileInput" accept=".json" style="display: none;">
                <button type="button" class="btn btn-outline-secondary btn-sm" onclick="document.getElementById('configFileInput').click()">
                    <i class="bi bi-upload"></i> Load
                </button>
                <button type="button" class="btn btn-outline-secondary btn-sm" id="saveConfigBtn">
                    <i class="bi bi-download"></i> Save
                </button>
                <button type="button" class="btn btn-primary btn-sm" id="connectBtn">
                    <i class="bi bi-plug"></i> Connect
                </button>
                <button type="button" class="btn btn-danger btn-sm" id="disconnectBtn" disabled>
                    <i class="bi bi-plug-fill"></i> Disconnect
                </button>
                <button type="button" class="btn btn-warning btn-sm" id="testConnectionBtn">
                    <i class="bi bi-activity"></i> Test
                </button>
                <button type="button" class="btn btn-info btn-sm" id="refreshTokenBtn">
                    <i class="bi bi-arrow-clockwise"></i> Token
                </button>
            </div>

            <!-- Accordion for Advanced Settings -->
            <div class="accordion" id="settingsAccordion">
                <!-- Presence & BLF -->
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#presenceSettings">
                            <i class="bi bi-eye me-2"></i> Presence & BLF
                        </button>
                    </h2>
                    <div id="presenceSettings" class="accordion-collapse collapse" data-bs-parent="#settingsAccordion">
                        <div class="accordion-body">
                            <div class="form-check mb-3">
                                <input type="checkbox" class="form-check-input" id="presenceEnabled">
                                <label class="form-check-label" for="presenceEnabled">Enable Presence & BLF</label>
                            </div>
                            <div id="presenceSettingsRow">
                                <div class="mb-2">
                                    <label for="presenceSubscriptions" class="form-label small">Watch Extensions</label>
                                    <input type="text" class="form-control form-control-sm" id="presenceSubscriptions" placeholder="1001,1002,1003">
                                </div>
                                <div class="row">
                                    <div class="col-6">
                                        <label for="presenceExpires" class="form-label small">Presence Expires</label>
                                        <input type="number" class="form-control form-control-sm" id="presenceExpires" value="600" min="60">
                                    </div>
                                    <div class="col-6">
                                        <label for="publishExpires" class="form-label small">Publish Expires</label>
                                        <input type="number" class="form-control form-control-sm" id="publishExpires" value="300" min="60">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- TURN Relay -->
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#turnSettings">
                            <i class="bi bi-arrow-repeat me-2"></i> TURN Relay
                        </button>
                    </h2>
                    <div id="turnSettings" class="accordion-collapse collapse" data-bs-parent="#settingsAccordion">
                        <div class="accordion-body">
                            <div class="form-check mb-3">
                                <input type="checkbox" class="form-check-input" id="turnEnabled">
                                <label class="form-check-label" for="turnEnabled">Enable TURN Relay</label>
                                <small class="d-block text-muted">Use TURN servers for NAT traversal</small>
                            </div>
                            <div id="turnSettingsRow">
                                <div class="mb-2">
                                    <label for="turnServer" class="form-label small">TURN Server</label>
                                    <input type="text" class="form-control form-control-sm" id="turnServer" placeholder="turn:server.example.com:3478">
                                </div>
                                <div class="mb-2">
                                    <label for="turnUsername" class="form-label small">Username</label>
                                    <input type="text" class="form-control form-control-sm" id="turnUsername" placeholder="username">
                                </div>
                                <div class="mb-2">
                                    <label for="turnCredential" class="form-label small">Credential</label>
                                    <input type="password" class="form-control form-control-sm" id="turnCredential" placeholder="credential">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SIP Instance -->
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#instanceSettings">
                            <i class="bi bi-fingerprint me-2"></i> SIP Instance
                        </button>
                    </h2>
                    <div id="instanceSettings" class="accordion-collapse collapse" data-bs-parent="#settingsAccordion">
                        <div class="accordion-body">
                            <div class="form-check">
                                <input type="checkbox" class="form-check-input" id="sipInstanceEnabled" checked>
                                <label class="form-check-label" for="sipInstanceEnabled">Use +sip.instance</label>
                                <small class="d-block text-muted">Prevents duplicate contact registrations</small>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Correlation ID -->
                <div class="accordion-item">
                    <h2 class="accordion-header">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#correlationSettings">
                            <i class="bi bi-link-45deg me-2"></i> Correlation ID
                        </button>
                    </h2>
                    <div id="correlationSettings" class="accordion-collapse collapse" data-bs-parent="#settingsAccordion">
                        <div class="accordion-body">
                            <div class="form-check">
                                <input type="checkbox" class="form-check-input" id="correlationIdEnabled">
                                <label class="form-check-label" for="correlationIdEnabled">Send X-RP-Correlation-ID</label>
                                <small class="d-block text-muted">Adds a unique UUIDv4 header to each outbound INVITE for call tracing</small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container-fluid main-content">
        <div class="row">
            <!-- Left Column: Account, Quick Dial, Favorites, Presence -->
            <div class="col-lg-3 side-panel-col" id="leftCol">
                <!-- Account Info Card -->
                <div class="card mb-3">
                    <div class="card-header py-2">
                        <h6 class="mb-0"><i class="bi bi-person-circle"></i> Account</h6>
                    </div>
                    <div class="card-body py-2">
                        <div class="small">
                            <div class="d-flex justify-content-between">
                                <span class="text-muted">User:</span>
                                <span id="accountUser" class="fw-bold text-truncate ms-2">-</span>
                            </div>
                            <div class="d-flex justify-content-between">
                                <span class="text-muted">Domain:</span>
                                <span id="accountDomain" class="text-truncate ms-2">-</span>
                            </div>
                            <div class="d-flex justify-content-between">
                                <span class="text-muted">Reg Expiry:</span>
                                <span id="accountRegExpiry" class="text-truncate ms-2">-</span>
                            </div>
                        </div>
                        <!-- DND Toggle -->
                        <div class="border-top mt-2 pt-2">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" id="dndToggle">
                                <label class="form-check-label small" for="dndToggle">
                                    <i class="bi bi-moon-fill text-warning"></i> Do Not Disturb
                                </label>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Audio Devices Card -->
                <div class="card mb-3">
                    <div class="card-header py-2">
                        <h6 class="mb-0"><i class="bi bi-headset"></i> Audio Devices</h6>
                    </div>
                    <div class="card-body py-2">
                        <div class="mb-2">
                            <label class="form-label small mb-1"><i class="bi bi-mic"></i> Microphone</label>
                            <select class="form-select form-select-sm" id="micSelect">
                                <option value="">Default</option>
                            </select>
                        </div>
                        <div>
                            <label class="form-label small mb-1"><i class="bi bi-speaker"></i> Speaker</label>
                            <select class="form-select form-select-sm" id="speakerSelect">
                                <option value="">Default</option>
                            </select>
                        </div>
                        <button class="btn btn-sm btn-outline-secondary w-100 mt-2" id="refreshDevicesBtn">
                            <i class="bi bi-arrow-clockwise"></i> Refresh
                        </button>
                    </div>
                </div>

                <!-- Favorites Card -->
                <div class="card mb-3">
                    <div class="card-header py-2 d-flex justify-content-between align-items-center">
                        <h6 class="mb-0"><i class="bi bi-star-fill text-warning"></i> Favorites</h6>
                    </div>
                    <div class="card-body py-2">
                        <div id="favoritesList" style="max-height: 120px; overflow-y: auto;">
                            <div class="text-muted text-center small">No favorites yet</div>
                        </div>
                    </div>
                </div>

                <!-- Quick Dial Card -->
                <div class="card mb-3">
                    <div class="card-header py-2 d-flex justify-content-between align-items-center">
                        <h6 class="mb-0"><i class="bi bi-lightning-fill text-primary"></i> Quick Dial</h6>
                        <button class="btn btn-sm btn-link p-0" id="addQuickDialBtn" title="Add Quick Dial">
                            <i class="bi bi-plus-circle"></i>
                        </button>
                    </div>
                    <div class="card-body py-2">
                        <div id="quickDialList" style="max-height: 150px; overflow-y: auto;">
                            <div class="text-muted text-center small">No quick dials set</div>
                        </div>
                    </div>
                </div>

                <!-- Presence Panel (shown when enabled) -->
                <div class="card side-panel" id="presencePanel" style="display: none;">
                    <div class="card-header py-2">
                        <h6 class="mb-0"><i class="bi bi-eye"></i> Presence</h6>
                    </div>
                    <div class="card-body py-2">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div>
                                <small class="text-muted">My Status:</small>
                                <span id="myPresenceStatus" class="badge bg-secondary ms-1">Unknown</span>
                            </div>
                            <div>
                                <span id="subscriptionCount" class="badge bg-info">0</span>
                                <small class="text-muted">active</small>
                            </div>
                        </div>
                        <div id="presenceList" style="max-height: 150px; overflow-y: auto;">
                            <div class="text-muted text-center small">Presence info appears here...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center Column: Dialer -->
            <div class="col-lg-6">
                <div class="card dialer-card">
                    <div class="card-body">
                        <!-- Phone Number Input -->
                        <div class="mb-3">
                            <div class="input-group input-group-lg">
                                <input type="text" class="form-control" id="phoneNumber" placeholder="Enter number">
                                <button class="btn btn-outline-secondary" type="button" id="clearNumber">
                                    <i class="bi bi-backspace"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Number Pad -->
                        <div class="number-pad mb-3">
                            <div class="pad-row">
                                <button class="btn btn-outline-primary" data-digit="1">1</button>
                                <button class="btn btn-outline-primary" data-digit="2">2<small>ABC</small></button>
                                <button class="btn btn-outline-primary" data-digit="3">3<small>DEF</small></button>
                            </div>
                            <div class="pad-row">
                                <button class="btn btn-outline-primary" data-digit="4">4<small>GHI</small></button>
                                <button class="btn btn-outline-primary" data-digit="5">5<small>JKL</small></button>
                                <button class="btn btn-outline-primary" data-digit="6">6<small>MNO</small></button>
                            </div>
                            <div class="pad-row">
                                <button class="btn btn-outline-primary" data-digit="7">7<small>PQRS</small></button>
                                <button class="btn btn-outline-primary" data-digit="8">8<small>TUV</small></button>
                                <button class="btn btn-outline-primary" data-digit="9">9<small>WXYZ</small></button>
                            </div>
                            <div class="pad-row">
                                <button class="btn btn-outline-primary" data-digit="*">*</button>
                                <button class="btn btn-outline-primary" data-digit="0">0</button>
                                <button class="btn btn-outline-primary" data-digit="#">#</button>
                            </div>
                        </div>

                        <!-- Call Button -->
                        <div class="d-grid mb-3">
                            <button type="button" class="btn btn-success btn-lg" id="callBtn" disabled>
                                <i class="bi bi-telephone-fill"></i> Call
                            </button>
                        </div>

                        <!-- In-Call Controls (shown during calls) -->
                        <div id="inCallControls" class="d-none">
                            <div class="row g-2 mb-3">
                                <div class="col-4">
                                    <button type="button" class="btn btn-danger w-100" id="hangupBtn" disabled>
                                        <i class="bi bi-telephone-x"></i> Hangup
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button type="button" class="btn btn-warning w-100" id="holdBtn" disabled>
                                        <i class="bi bi-pause-fill"></i> Hold
                                    </button>
                                </div>
                                <div class="col-4">
                                    <button type="button" class="btn btn-info w-100" id="transferBtn" disabled>
                                        <i class="bi bi-telephone-forward"></i> Transfer
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Call Info Card (shown during calls) -->
                        <div id="callInfoCard" class="card call-info-card d-none">
                            <div class="card-body py-2">
                                <!-- Single Call View -->
                                <div id="singleCallView" class="call-info">
                                    <div class="row">
                                        <div class="col-6">
                                            <small class="text-muted">Status</small>
                                            <div class="fw-bold" id="callStatus">Idle</div>
                                        </div>
                                        <div class="col-6">
                                            <small class="text-muted">Duration</small>
                                            <div class="fw-bold" id="callDuration">00:00</div>
                                        </div>
                                    </div>
                                    <div class="row mt-2">
                                        <div class="col-6">
                                            <small class="text-muted">Remote Party</small>
                                            <div id="remoteParty">-</div>
                                        </div>
                                        <div class="col-6">
                                            <small class="text-muted">Local URI</small>
                                            <div class="small text-truncate" id="localUri">-</div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Transfer Split View -->
                                <div id="transferSplitView" class="d-none">
                                    <div class="row">
                                        <div class="col-6">
                                            <div class="card bg-light mb-2">
                                                <div class="card-body py-1 px-2">
                                                    <small class="text-muted">Primary (Hold)</small>
                                                    <div class="small fw-bold" id="primaryCallParty">-</div>
                                                    <span class="badge bg-warning text-dark">On Hold</span>
                                                    <span class="small" id="primaryCallDuration">00:00</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="col-6">
                                            <div class="card border-success mb-2">
                                                <div class="card-body py-1 px-2">
                                                    <small class="text-success">Transfer To</small>
                                                    <div class="small fw-bold" id="transferCallParty">-</div>
                                                    <span class="badge bg-info" id="transferCallStatus">Calling...</span>
                                                    <span class="small" id="transferCallDuration">00:00</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="row g-2">
                                        <div class="col-6">
                                            <button type="button" class="btn btn-success btn-sm w-100" id="completeTransferBtn">
                                                <i class="bi bi-check"></i> Complete
                                            </button>
                                        </div>
                                        <div class="col-6">
                                            <button type="button" class="btn btn-secondary btn-sm w-100" id="cancelTransferBtn">
                                                <i class="bi bi-x"></i> Cancel
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Audio Controls -->
                                <div class="border-top mt-2 pt-2">
                                    <div class="row align-items-center">
                                        <div class="col-auto">
                                            <button class="btn btn-sm btn-outline-secondary" id="muteBtn">
                                                <i class="bi bi-mic"></i>
                                            </button>
                                        </div>
                                        <div class="col">
                                            <small class="text-muted d-block">Mic</small>
                                            <input type="range" class="form-range form-range-sm" id="micVolume" min="0" max="100" value="100">
                                        </div>
                                        <div class="col">
                                            <small class="text-muted d-block">Speaker <span class="badge bg-secondary" id="volumeValue">100%</span></small>
                                            <input type="range" class="form-range form-range-sm" id="speakerVolume" min="0" max="100" value="100">
                                        </div>
                                    </div>
                                    <!-- DTMF Inline -->
                                    <div class="dtmf-inline mt-2">
                                        <small class="text-muted">DTMF:</small>
                                        <div class="btn-group btn-group-sm ms-2">
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="1">1</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="2">2</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="3">3</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="4">4</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="5">5</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="6">6</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="7">7</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="8">8</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="9">9</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="*">*</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="0">0</button>
                                            <button type="button" class="btn btn-outline-secondary dtmf-btn" data-tone="#">#</button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Audio Container -->
                                <div id="audioContainer" class="mt-2 d-none"></div>
                            </div>
                        </div>

                        <!-- Custom SIP Headers Card (shown during calls) -->
                        <div id="customHeadersCard" class="card custom-headers-card mt-2 d-none">
                            <div class="card-body py-2">
                                <div class="d-flex justify-content-between align-items-center mb-1">
                                    <small class="text-muted fw-bold">Custom SIP Headers</small>
                                    <span class="badge bg-secondary" id="customHeaderCount">0</span>
                                </div>
                                <div id="customHeadersList"></div>
                                <div id="noCustomHeaders" class="text-muted small">No custom headers received</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Call History + Debug -->
            <div class="col-lg-3 side-panel-col" id="historyCol">
                <!-- Call History -->
                <div class="card side-panel mb-3">
                    <div class="card-header py-2 d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">
                            <i class="bi bi-clock-history"></i> History
                            <span id="missedCallBadge" class="badge bg-danger ms-1" style="display: none;">0</span>
                        </h6>
                        <div>
                            <button class="btn btn-sm btn-link text-danger p-0 me-2" id="clearMissedBtn" style="display: none;" title="Clear Missed">
                                <i class="bi bi-check-all"></i>
                            </button>
                            <button class="btn btn-sm btn-link text-secondary p-0" id="clearHistoryBtn" title="Clear All">
                                <i class="bi bi-trash"></i>
                            </button>
                        </div>
                    </div>
                    <div class="card-body py-2">
                        <div id="callHistoryList" style="max-height: 250px; overflow-y: auto;">
                            <div class="text-muted text-center small">No calls yet</div>
                        </div>
                    </div>
                </div>

                <!-- Debug Log (Collapsible) -->
                <div class="card">
                    <div class="card-header py-2">
                        <a class="text-decoration-none d-flex justify-content-between align-items-center" data-bs-toggle="collapse" href="#debugCollapse">
                            <h6 class="mb-0"><i class="bi bi-bug"></i> Debug Log</h6>
                            <i class="bi bi-chevron-down"></i>
                        </a>
                    </div>
                    <div class="collapse" id="debugCollapse">
                        <div class="card-body py-2">
                            <div id="debugLog" style="height: 200px; overflow-y: auto; font-family: monospace; font-size: 0.7rem; background-color: #f8f9fa; padding: 8px; border-radius: 4px;">
                                <div class="text-muted">Debug info appears here...</div>
                            </div>
                            <button class="btn btn-sm btn-outline-secondary mt-2" id="clearLogBtn">Clear</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Incoming Call Modal -->
        <div class="modal fade" id="incomingCallModal" tabindex="-1" aria-labelledby="incomingCallModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header bg-success text-white">
                        <h5 class="modal-title" id="incomingCallModalLabel">
                            <i class="bi bi-telephone-inbound"></i> Incoming Call
                        </h5>
                    </div>
                    <div class="modal-body text-center">
                        <div class="mb-3">
                            <i class="bi bi-person-circle" style="font-size: 4rem; color: #28a745;"></i>
                        </div>
                        <h4 id="incomingCallerName" class="mb-2">Unknown Caller</h4>
                        <p id="incomingCallerNumber" class="text-muted mb-4">-</p>
                        <div class="row">
                            <div class="col-6">
                                <button type="button" class="btn btn-danger btn-lg w-100" id="declineCallBtn">
                                    <i class="bi bi-telephone-x"></i><br>Decline
                                </button>
                            </div>
                            <div class="col-6">
                                <button type="button" class="btn btn-success btn-lg w-100" id="acceptCallBtn">
                                    <i class="bi bi-telephone"></i><br>Accept
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Transfer Modal -->
        <div class="modal fade" id="transferModal" tabindex="-1" aria-labelledby="transferModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header bg-info text-white">
                        <h5 class="modal-title" id="transferModalLabel">
                            <i class="bi bi-telephone-forward"></i> Transfer Call
                        </h5>
                        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="transferTarget" class="form-label">Transfer To:</label>
                            <input type="text" class="form-control" id="transferTarget" placeholder="Enter phone number or extension">
                        </div>
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-primary" id="blindTransferBtn">
                                <i class="bi bi-telephone-forward-fill"></i> Blind Transfer
                                <small class="d-block text-light">Transfer immediately without speaking to recipient</small>
                            </button>
                            <button type="button" class="btn btn-success" id="attendedTransferBtn">
                                <i class="bi bi-people"></i> Attended Transfer
                                <small class="d-block text-light">Speak to recipient before transferring</small>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-bottom-nav">
        <div class="nav-item">
            <a class="nav-link" href="#" data-bs-toggle="offcanvas" data-bs-target="#presenceOffcanvas">
                <i class="bi bi-eye"></i>
                Presence
            </a>
        </div>
        <div class="nav-item">
            <a class="nav-link active" href="#">
                <i class="bi bi-telephone"></i>
                Dialer
            </a>
        </div>
        <div class="nav-item">
            <a class="nav-link" href="#" data-bs-toggle="offcanvas" data-bs-target="#historyOffcanvas">
                <i class="bi bi-clock-history"></i>
                History
                <span id="missedCallBadgeMobile" class="badge bg-danger" style="display: none; position: absolute; top: 0; right: 25%;">0</span>
            </a>
        </div>
        <div class="nav-item">
            <a class="nav-link" href="#" data-bs-toggle="offcanvas" data-bs-target="#debugOffcanvas">
                <i class="bi bi-bug"></i>
                Debug
            </a>
        </div>
    </nav>

    <!-- Mobile Offcanvas Panels -->
    <!-- Presence Offcanvas (Mobile) -->
    <div class="offcanvas offcanvas-start" tabindex="-1" id="presenceOffcanvas">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title"><i class="bi bi-eye"></i> Presence Status</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body offcanvas-panel">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div>
                    <strong>My Status:</strong>
                    <span id="myPresenceStatusMobile" class="badge bg-secondary ms-2">Unknown</span>
                </div>
                <div>
                    <span id="subscriptionCountMobile" class="badge bg-info">0</span> active
                </div>
            </div>
            <div id="presenceListMobile" style="max-height: calc(80vh - 100px); overflow-y: auto;">
                <div class="text-muted text-center">Presence info appears here...</div>
            </div>
        </div>
    </div>

    <!-- History Offcanvas (Mobile) -->
    <div class="offcanvas offcanvas-end" tabindex="-1" id="historyOffcanvas">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title">
                <i class="bi bi-clock-history"></i> Call History
                <span id="missedCallBadgeOffcanvas" class="badge bg-danger ms-2" style="display: none;">0</span>
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body offcanvas-panel">
            <div class="mb-2">
                <button class="btn btn-sm btn-outline-danger me-2" id="clearMissedBtnMobile" style="display: none;">
                    <i class="bi bi-check-all"></i> Clear Missed
                </button>
                <button class="btn btn-sm btn-outline-secondary" id="clearHistoryBtnMobile">
                    <i class="bi bi-trash"></i> Clear All
                </button>
            </div>
            <div id="callHistoryListMobile" style="max-height: calc(80vh - 120px); overflow-y: auto;">
                <div class="text-muted text-center">No calls yet</div>
            </div>
        </div>
    </div>

    <!-- Debug Offcanvas (Mobile) -->
    <div class="offcanvas offcanvas-bottom" tabindex="-1" id="debugOffcanvas" style="height: 50vh;">
        <div class="offcanvas-header">
            <h5 class="offcanvas-title"><i class="bi bi-bug"></i> Debug Log</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
        </div>
        <div class="offcanvas-body offcanvas-panel">
            <div id="debugLogMobile" style="height: calc(50vh - 100px); overflow-y: auto; font-family: monospace; font-size: 0.75rem; background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
                <div class="text-muted">Debug info appears here...</div>
            </div>
            <button class="btn btn-sm btn-outline-secondary mt-2" id="clearLogBtnMobile">Clear Log</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        class SoftPhone {
            constructor() {
                // Core SIP properties
                this.ua = null;
                this.currentSession = null;
                this.isConnected = false;
                this.isRegistered = false;
                this.callTimer = null;
                this.callStartTime = null;
                this.isMuted = false;
                this.isOnHold = false;
                this.incomingCallModal = null;
                this.pendingInvitation = null;
                this.incomingCallCancelled = false;
                this.callHistory = [];
                this.missedCallCount = 0;
                this.registerer = null;

                // JWT Authentication
                this.jwtToken = null;

                // Presence properties
                this.presenceEnabled = false;
                this.publishExpires = 300;
                this.presenceExpires = 600;
                this.watchedExtensions = [];
                this.presenceStates = new Map(); // aor -> state object
                this.activeSubscribers = new Map(); // aor -> Subscriber instance
                this.publishTimer = null;
                this.subscriptionTimers = new Map(); // aor -> timer
                this.myPresenceState = 'open'; // 'open' | 'closed'
                this.myCallState = 'idle'; // 'idle' | 'ringing' | 'in_call'
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectTimer = null;
                this.isIntentionalDisconnect = false;

                // Transfer properties
                this.isTransferMode = false;
                this.primarySession = null;
                this.transferTargetSession = null;
                this.primaryCallInfo = null;  // Stores info about the primary call during transfer

                // New features
                this.quickDials = [];
                this.favorites = [];
                this.isDND = false;
                this.registrationExpiry = null;
                this.regExpiryTimer = null;
                this.regExpiryWarningThreshold = 120; // orange warning at 2 min remaining
                this.regExpiryDangerThreshold = 30;   // red danger at 30s remaining
                this.selectedMicId = null;
                this.selectedSpeakerId = null;

                this.loadSettings();
                this.loadCallHistory();
                this.loadMissedCallCount();
                this.loadQuickDials();
                this.loadFavorites();
                this.initializeEventListeners();
                this.enumerateAudioDevices();
                this.log('Softphone initialised (JWT Authentication Mode)');
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                const className = `text-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'dark'}`;

                // Update desktop debug log
                const debugLog = document.getElementById('debugLog');
                const div = document.createElement('div');
                div.className = className;
                div.textContent = logEntry;
                debugLog.appendChild(div);
                debugLog.scrollTop = debugLog.scrollHeight;

                // Update mobile debug log
                const debugLogMobile = document.getElementById('debugLogMobile');
                if (debugLogMobile) {
                    const divMobile = document.createElement('div');
                    divMobile.className = className;
                    divMobile.textContent = logEntry;
                    debugLogMobile.appendChild(divMobile);
                    debugLogMobile.scrollTop = debugLogMobile.scrollHeight;
                }

                console.log(logEntry);
            }

            initializeEventListeners() {
                // Presence controls
                document.getElementById('presenceEnabled').addEventListener('change', (e) => {
                    this.togglePresenceSettings(e.target.checked);
                    this.saveSettings();
                });

                // TURN toggle
                document.getElementById('turnEnabled').addEventListener('change', (e) => {
                    this.toggleTurnSettings(e.target.checked);
                    this.saveSettings();
                });

                // TURN settings
                document.getElementById('turnServer').addEventListener('input', () => this.saveSettings());
                document.getElementById('turnUsername').addEventListener('input', () => this.saveSettings());
                document.getElementById('turnCredential').addEventListener('input', () => this.saveSettings());

                // SIP instance toggle
                document.getElementById('sipInstanceEnabled').addEventListener('change', () => this.saveSettings());
                document.getElementById('correlationIdEnabled').addEventListener('change', () => this.saveSettings());

                // Connection controls
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('testConnectionBtn').addEventListener('click', () => this.testConnection());
                document.getElementById('refreshTokenBtn').addEventListener('click', () => this.refreshToken());
                document.getElementById('configFileInput').addEventListener('change', (e) => this.loadConfigFile(e));

                // Save settings when they change
                document.getElementById('wsServer').addEventListener('input', () => this.saveSettings());
                document.getElementById('sipUser').addEventListener('input', () => this.saveSettings());
                document.getElementById('jwtToken').addEventListener('input', () => this.saveSettings());
                document.getElementById('sipDomain').addEventListener('input', () => this.saveSettings());
                document.getElementById('presenceSubscriptions').addEventListener('input', () => this.saveSettings());
                document.getElementById('presenceExpires').addEventListener('input', () => this.saveSettings());
                document.getElementById('publishExpires').addEventListener('input', () => this.saveSettings());

                // Dialer controls
                document.getElementById('callBtn').addEventListener('click', () => this.makeCall());
                document.getElementById('hangupBtn').addEventListener('click', () => this.hangupCall());
                document.getElementById('holdBtn').addEventListener('click', () => this.toggleHold());
                document.getElementById('clearNumber').addEventListener('click', () => this.clearNumber());

                // Number pad
                document.querySelectorAll('[data-digit]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const digit = e.currentTarget.getAttribute('data-digit');
                        this.addDigit(digit);
                    });
                });

                // DTMF buttons
                document.querySelectorAll('.dtmf-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tone = e.currentTarget.getAttribute('data-tone');
                        this.sendDTMF(tone);
                    });
                });

                // Audio controls
                document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                document.getElementById('speakerVolume').addEventListener('input', (e) => {
                    this.setSpeakerVolume(e.target.value);
                });
                document.getElementById('micVolume').addEventListener('input', (e) => {
                    this.setMicrophoneVolume(e.target.value);
                });

                // Debug controls
                document.getElementById('clearLogBtn').addEventListener('click', () => this.clearLog());

                // Phone number input
                document.getElementById('phoneNumber').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.makeCall();
                    }
                });

                // Incoming call modal controls
                document.getElementById('acceptCallBtn').addEventListener('click', () => this.acceptIncomingCall());
                document.getElementById('declineCallBtn').addEventListener('click', () => this.declineIncomingCall());

                // Transfer controls
                document.getElementById('transferBtn').addEventListener('click', () => this.showTransferModal());
                document.getElementById('blindTransferBtn').addEventListener('click', () => this.blindTransfer());
                document.getElementById('attendedTransferBtn').addEventListener('click', () => this.startAttendedTransfer());
                document.getElementById('completeTransferBtn').addEventListener('click', () => this.completeAttendedTransfer());
                document.getElementById('cancelTransferBtn').addEventListener('click', () => this.cancelTransfer());

                // Call history controls
                document.getElementById('clearHistoryBtn').addEventListener('click', () => this.clearCallHistory());
                document.getElementById('clearMissedBtn').addEventListener('click', () => this.clearMissedCallCount());

                // Save config button
                document.getElementById('saveConfigBtn').addEventListener('click', () => this.saveConfigFile());

                // Mobile controls
                const clearHistoryBtnMobile = document.getElementById('clearHistoryBtnMobile');
                if (clearHistoryBtnMobile) {
                    clearHistoryBtnMobile.addEventListener('click', () => this.clearCallHistory());
                }
                const clearMissedBtnMobile = document.getElementById('clearMissedBtnMobile');
                if (clearMissedBtnMobile) {
                    clearMissedBtnMobile.addEventListener('click', () => this.clearMissedCallCount());
                }
                const clearLogBtnMobile = document.getElementById('clearLogBtnMobile');
                if (clearLogBtnMobile) {
                    clearLogBtnMobile.addEventListener('click', () => this.clearLog());
                }

                // DND toggle
                document.getElementById('dndToggle').addEventListener('change', (e) => {
                    this.toggleDND(e.target.checked);
                });

                // Audio device controls
                document.getElementById('refreshDevicesBtn').addEventListener('click', () => this.enumerateAudioDevices());
                document.getElementById('micSelect').addEventListener('change', (e) => {
                    this.selectedMicId = e.target.value;
                    this.saveSettings();
                });
                document.getElementById('speakerSelect').addEventListener('change', (e) => {
                    this.selectedSpeakerId = e.target.value;
                    this.applyAudioOutput();
                    this.saveSettings();
                });

                // Quick dial
                document.getElementById('addQuickDialBtn').addEventListener('click', () => this.showAddQuickDialModal());
            }

            togglePresenceSettings(enabled) {
                const panel = document.getElementById('presencePanel');
                panel.style.display = enabled ? 'block' : 'none';
            }

            toggleTurnSettings(enabled) {
                // No need to toggle visibility in accordion-based settings
            }

            // JWT Authentication Helper - Get Authorization header
            getAuthorizationHeader() {
                if (!this.jwtToken) {
                    this.log('No JWT token available for authorization', 'error');
                    return null;
                }
                return `Bearer ${this.jwtToken}`;
            }

            refreshToken() {
                const newToken = document.getElementById('jwtToken').value.trim();
                if (!newToken) {
                    this.log('Please enter a JWT token', 'error');
                    this.showError('JWT token is required');
                    return;
                }

                this.jwtToken = newToken;
                this.saveSettings();
                this.log('JWT token updated', 'success');

                // If connected, suggest reconnection
                if (this.isConnected) {
                    this.log('Token updated. You may need to reconnect for the new token to take effect.', 'info');
                    this.showError('Token updated. Please reconnect to use the new token.');
                }
            }

            buildIceServers() {
                // Always include Google STUN server
                const iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' }
                ];

                // Add TURN servers if enabled and configured
                const turnEnabled = document.getElementById('turnEnabled').checked;
                if (turnEnabled) {
                    const turnServer = document.getElementById('turnServer').value.trim();
                    const turnUsername = document.getElementById('turnUsername').value.trim();
                    const turnCredential = document.getElementById('turnCredential').value;

                    if (turnServer && turnUsername && turnCredential) {
                        this.log('TURN relay enabled - adding configured TURN server', 'info');

                        // Add the configured TURN server
                        iceServers.push({
                            urls: turnServer,
                            username: turnUsername,
                            credential: turnCredential
                        });

                        // Also add TCP transport variant if it's a standard TURN URL
                        if (turnServer.startsWith('turn:') && !turnServer.includes('transport=')) {
                            iceServers.push({
                                urls: turnServer + '?transport=tcp',
                                username: turnUsername,
                                credential: turnCredential
                            });
                        }
                    } else {
                        this.log('TURN enabled but credentials not configured - using STUN only', 'warning');
                    }
                } else {
                    this.log('TURN relay disabled - using STUN only', 'info');
                }

                return iceServers;
            }

            async connect() {
                const wsServer = document.getElementById('wsServer').value;
                const sipUser = document.getElementById('sipUser').value;
                const jwtToken = document.getElementById('jwtToken').value.trim();
                const sipDomain = document.getElementById('sipDomain').value;

                if (!wsServer || !sipUser || !jwtToken || !sipDomain) {
                    this.log('Please fill in all connection fields (including JWT token)', 'error');
                    this.showError('All fields are required: WebSocket Server, SIP User, JWT Token, and Domain');
                    return;
                }

                // Store JWT token
                this.jwtToken = jwtToken;

                this.log(`Attempting to connect to: ${wsServer}`);
                this.log(`SIP URI will be: sip:${sipUser}@${sipDomain}`);
                this.log('Using JWT Bearer authentication (RFC 8898)', 'info');
                this.updateConnectionStatus('connecting');

                // Validate WebSocket URL format
                try {
                    new URL(wsServer);
                } catch (urlError) {
                    this.log(`Invalid WebSocket URL format: ${wsServer}`, 'error');
                    this.showError(`Invalid WebSocket URL: ${urlError.message}`);
                    this.updateConnectionStatus('disconnected');
                    return;
                }

                // Check if WebSocket URL uses secure connection for HTTPS pages
                if (window.location.protocol === 'https:' && wsServer.startsWith('ws://')) {
                    this.log('Warning: Using insecure WebSocket (ws://) on HTTPS page may fail due to mixed content policy', 'error');
                    this.showError('Warning: Mixed content - use wss:// for HTTPS pages');
                }

                try {
                    const uri = SIP.UserAgent.makeURI(`sip:${sipUser}@${sipDomain}`);
                    if (!uri) {
                        throw new Error(`Failed to create SIP URI from: sip:${sipUser}@${sipDomain}`);
                    }

                    this.log(`Created SIP URI: ${uri.toString()}`);

                    const transportOptions = {
                        server: wsServer,
                        connectionTimeout: 10000,
                        maxReconnectionAttempts: 3,
                        reconnectionTimeout: 4000
                    };

                    // Build ICE servers configuration
                    const iceServers = this.buildIceServers();
                    this.log(`ICE servers configured: ${iceServers.length} server(s)`, 'info');

                    // UserAgent options WITHOUT Digest authentication
                    const userAgentOptions = {
                        uri: uri,
                        transportOptions: transportOptions,
                        // NO authorizationUsername or authorizationPassword - using JWT instead
                        sessionDescriptionHandlerFactoryOptions: {
                            constraints: {
                                audio: true,
                                video: false
                            },
                            peerConnectionConfiguration: {
                                iceServers: iceServers
                            }
                        }
                    };

                    // Conditionally prepare +sip.instance for Registerer based on toggle
                    if (document.getElementById('sipInstanceEnabled').checked) {
                        this.instanceId = localStorage.getItem('sipphone-instance-id');
                        if (!this.instanceId) {
                            this.instanceId = crypto.randomUUID();
                            localStorage.setItem('sipphone-instance-id', this.instanceId);
                        }
                        this.log(`Using +sip.instance: ${this.instanceId}`, 'info');
                    } else {
                        this.instanceId = null;
                        this.log('+sip.instance disabled', 'info');
                    }

                    this.log('Creating SIP UserAgent with JWT authentication:', 'info');
                    this.log(`- Server: ${transportOptions.server}`, 'info');
                    this.log(`- Timeout: ${transportOptions.connectionTimeout}ms`, 'info');
                    this.log(`- User: ${sipUser}`, 'info');
                    this.log(`- Domain: ${sipDomain}`, 'info');
                    this.log(`- Auth: Bearer Token (RFC 8898)`, 'info');

                    this.ua = new SIP.UserAgent(userAgentOptions);

                    // Enhanced event handlers with detailed error reporting
                    this.ua.delegate = {
                        onConnect: () => {
                            this.log('WebSocket connection established successfully', 'success');
                            this.isConnected = true;
                            this.reconnectAttempts = 0;
                            this.isIntentionalDisconnect = false;
                            this.clearReconnectTimer();
                            this.updateConnectionStatus('connected');
                            this.register();
                        },
                        onDisconnect: (error) => {
                            const errorMsg = error ? error.message : 'Unknown disconnection reason';
                            this.log(`WebSocket disconnected: ${errorMsg}`, 'error');

                            // Provide more detailed error analysis
                            if (errorMsg.includes('1006')) {
                                this.log('Connection closed abnormally (code 1006) - possible causes:', 'error');
                                this.log(' Server is not running or not accepting WebSocket connections', 'error');
                                this.log(' Firewall or proxy blocking the connection', 'error');
                                this.log(' Invalid server address or port', 'error');
                                this.log(' SSL/TLS certificate issues (for wss://)', 'error');
                                this.showError('Connection failed: Server unreachable or WebSocket endpoint not available');
                            } else if (errorMsg.includes('1000')) {
                                this.log('Normal closure (code 1000) - Server closed connection normally', 'info');
                            } else if (errorMsg.includes('1001')) {
                                this.log('Endpoint going away (code 1001) - Server shutting down', 'error');
                            } else if (errorMsg.includes('1002')) {
                                this.log('Protocol error (code 1002) - WebSocket protocol violation', 'error');
                            } else if (errorMsg.includes('1003')) {
                                this.log('Unsupported data (code 1003) - Server received unsupported data type', 'error');
                            } else if (errorMsg.includes('1007')) {
                                this.log('Invalid frame payload (code 1007) - Data encoding error', 'error');
                            } else if (errorMsg.includes('1008')) {
                                this.log('Policy violation (code 1008) - Server policy violation', 'error');
                            } else if (errorMsg.includes('1011')) {
                                this.log('Internal server error (code 1011) - Server encountered unexpected condition', 'error');
                            }

                            this.isConnected = false;
                            this.isRegistered = false;
                            this.handleDisconnection(error);
                            this.updateConnectionStatus('disconnected');
                            this.updateRegistrationStatus('');
                        },
                        onInvite: (invitation) => {
                            this.log(`Incoming call from: ${invitation.remoteIdentity.displayName || invitation.remoteIdentity.uri.user}`, 'success');
                            this.handleIncomingCall(invitation);
                        }
                    };

                    this.log('Starting SIP UserAgent...');
                    await this.ua.start();

                    document.getElementById('localUri').textContent = uri.toString();
                    this.log('UserAgent started successfully', 'success');

                } catch (error) {
                    this.log(`Connection failed: ${error.message}`, 'error');
                    this.log(`Error type: ${error.name}`, 'error');

                    // Provide specific troubleshooting based on error type
                    if (error.message.includes('WebSocket')) {
                        this.log('WebSocket-specific troubleshooting:', 'error');
                        this.log(' Verify the server address and port are correct', 'error');
                        this.log(' Check if the server supports WebSocket connections', 'error');
                        this.log(' Ensure no firewall is blocking the connection', 'error');
                        this.log(' Try using a different network or VPN', 'error');
                    } else if (error.message.includes('URI')) {
                        this.log('SIP URI troubleshooting:', 'error');
                        this.log(' Check username format (no spaces or special characters)', 'error');
                        this.log(' Verify domain format (e.g., localhost, domain.com)', 'error');
                        this.log(' Ensure no @ symbols in username field', 'error');
                    }

                    this.updateConnectionStatus('disconnected');
                    this.showError(`Connection failed: ${error.message}`);
                }
            }

            async register() {
                if (!this.ua) return;

                try {
                    this.log('Starting SIP registration process with JWT Bearer authentication...');

                    // Get authorization header
                    const authHeader = this.getAuthorizationHeader();
                    if (!authHeader) {
                        this.log('Cannot register without JWT token', 'error');
                        this.showError('JWT token is required for registration');
                        return;
                    }

                    // Create registerer with extra headers for Bearer token
                    const registererOptions = {
                        extraHeaders: [
                            `Authorization: ${authHeader}`
                        ]
                    };

                    // Add regId and instanceId if +sip.instance is enabled
                    if (this.instanceId) {
                        registererOptions.regId = 1;
                        registererOptions.instanceId = this.instanceId;
                    }

                    const registerer = new SIP.Registerer(this.ua, registererOptions);

                    // Wrap registerer.register() to intercept all REGISTER 200 OK responses,
                    // including SIP.js internal auto-refresh re-registrations.
                    const originalRegister = registerer.register.bind(registerer);
                    const self = this;
                    registerer.register = function(options = {}) {
                        const wrappedOptions = { ...options };
                        const originalOnAccept = wrappedOptions.requestDelegate?.onAccept;
                        wrappedOptions.requestDelegate = {
                            ...wrappedOptions.requestDelegate,
                            onAccept: (response) => {
                                const expires = self._extractExpiresFromResponse(response);
                                self.log(`Registration accepted, expires in ${expires}s`, 'success');
                                self.startRegExpiryCountdown(expires);
                                if (originalOnAccept) originalOnAccept(response);
                            }
                        };
                        return originalRegister(wrappedOptions);
                    };

                    registerer.stateChange.addListener((newState) => {
                        this.log(`Registration state changed: ${newState}`, newState === SIP.RegistererState.Registered ? 'success' : 'info');

                        if (newState === SIP.RegistererState.Registered) {
                            this.isRegistered = true;
                            this.updateRegistrationStatus('Registered', 'success');
                            this.updateStatusBarStyle('info');
                            this.enableControls(true);
                            this.log('Successfully registered with SIP server using JWT', 'success');

                            // Update account info (countdown is started by the onAccept wrapper)
                            this.updateAccountInfo();

                            // Initialise presence if enabled
                            if (document.getElementById('presenceEnabled').checked) {
                                this.initPresence();
                            }
                        } else if (newState === SIP.RegistererState.Unregistered) {
                            this.isRegistered = false;
                            this.updateRegistrationStatus('Unregistered - JWT token may be invalid or expired', 'warning');
                            this.updateStatusBarStyle('danger');
                            this.enableControls(false);
                            this.log('SIP registration lost', 'error');
                        } else if (newState === SIP.RegistererState.Terminated) {
                            this.isRegistered = false;
                            this.updateRegistrationStatus('Registration Failed - JWT token invalid or expired', 'error');
                            this.updateStatusBarStyle('danger');
                            this.enableControls(false);
                            this.log('SIP registration terminated', 'error');
                            this.log('This may indicate invalid or expired JWT token', 'error');
                            this.showError('Registration failed: Check if JWT token is valid and not expired');
                        }
                    });

                    registerer.stateChange.addListener((newState) => {
                        if (newState === SIP.RegistererState.Terminated) {
                            this.log('Registration failed - check JWT token validity and server configuration', 'error');
                            this.log('If you receive 401/407 errors, your JWT token may be invalid or expired', 'error');
                            this.showError('Registration failed: Verify JWT token is valid and server supports RFC 8898');
                        }
                    });

                    this.log('Sending REGISTER request with Bearer token...');
                    await registerer.register();
                    this.registerer = registerer;

                } catch (error) {
                    this.log(`Registration failed: ${error.message}`, 'error');

                    // Check for authentication errors
                    if (error.message.includes('401') || error.message.includes('407')) {
                        this.log('Authentication error: JWT token may be invalid or expired', 'error');
                        this.showError('Authentication failed: Please update your JWT token');
                    } else {
                        this.showError(`Registration failed: ${error.message}`);
                    }
                }
            }

            async disconnect() {
                // Mark this as an intentional disconnect to prevent auto-reconnection
                this.isIntentionalDisconnect = true;
                this.clearReconnectTimer();

                if (this.currentSession) {
                    this.hangupCall();
                }

                // Clean up presence
                this.cleanupPresence();

                if (this.registerer) {
                    try {
                        await this.registerer.unregister();
                    } catch (error) {
                        this.log(`Unregistration error: ${error.message}`, 'error');
                    }
                }

                if (this.ua) {
                    await this.ua.stop();
                    this.ua = null;
                }

                this.isConnected = false;
                this.isRegistered = false;
                this.updateConnectionStatus('disconnected');
                this.updateRegistrationStatus('', 'info');
                this.updateStatusBarStyle('info');
                this.enableControls(false);
                this.stopRegExpiryCountdown();
                this.log('Disconnected', 'info');
            }

            makeCall() {
                if (!this.isRegistered) {
                    this.log('Cannot make call: not registered', 'error');
                    return;
                }

                // Prevent making a new call if already on a call (unless in transfer mode)
                if (this.currentSession && !this.isTransferMode) {
                    this.log('Cannot make call: already on a call. Use transfer to call another party.', 'error');
                    return;
                }

                const phoneNumber = document.getElementById('phoneNumber').value;
                if (!phoneNumber) {
                    this.log('Please enter a phone number', 'error');
                    return;
                }

                try {
                    const sipDomain = document.getElementById('sipDomain').value;
                    const targetUri = SIP.UserAgent.makeURI(`sip:${phoneNumber}@${sipDomain}`);
                    if (!targetUri) {
                        throw new Error('Invalid phone number');
                    }

                    // Get authorization header
                    const authHeader = this.getAuthorizationHeader();
                    if (!authHeader) {
                        this.log('Cannot make call without JWT token', 'error');
                        return;
                    }

                    this.log(`Making call to: ${phoneNumber}`);

                    const extraHeaders = [`Authorization: ${authHeader}`];
                    if (document.getElementById('correlationIdEnabled').checked) {
                        const correlationId = crypto.randomUUID();
                        extraHeaders.push(`X-RP-Correlation-ID: ${correlationId}`);
                        this.log(`Call correlation ID: ${correlationId}`, 'info');
                    }

                    const inviter = new SIP.Inviter(this.ua, targetUri, { extraHeaders });
                    this.currentSession = inviter;
                    this.currentCallType = 'outgoing';

                    // Publish call state: ringing
                    this.publishCallState('ringing');

                    this.setupSessionHandlers(inviter);

                    inviter.invite({
                        sessionDescriptionHandlerOptions: {
                            constraints: { audio: true, video: false }
                        }
                    });

                    this.updateCallStatus('Calling...');
                    this.updateRemoteParty(phoneNumber);
                    this.enableCallControls(true);

                } catch (error) {
                    this.log(`Call failed: ${error.message}`, 'error');
                    this.showError(`Call failed: ${error.message}`);
                }
            }

            handleIncomingCall(invitation) {
                // Check DND status - auto decline if enabled
                if (this.isDND) {
                    const callerNumber = invitation.remoteIdentity.uri.user;
                    this.log(`DND active - auto declining call from ${callerNumber}`, 'info');
                    invitation.reject();
                    this.addCallToHistory('missed', callerNumber);
                    return;
                }

                this.pendingInvitation = invitation;

                // Handle server-initiated cancellation (answered elsewhere, caller hung up)
                this.pendingInvitation.delegate = {
                    ...this.pendingInvitation.delegate,
                    onCancel: (message) => {
                        const reasonHeader = message.getHeader('Reason');
                        const answeredElsewhere = reasonHeader && (
                            reasonHeader.includes('cause=26') ||
                            reasonHeader.includes('cause=200') ||
                            reasonHeader.toLowerCase().includes('answered elsewhere') ||
                            reasonHeader.toLowerCase().includes('completed elsewhere')
                        );

                        // Mark as cancelled to prevent clearCall() from adding to history
                        this.incomingCallCancelled = true;

                        if (answeredElsewhere) {
                            this.log('Call answered on another device', 'info');
                        } else {
                            // Genuine missed call - caller hung up before we answered
                            const callerNumber = this.pendingInvitation?.remoteIdentity?.uri?.user || 'Unknown';
                            this.addCallToHistory('missed', callerNumber);
                            this.log('Incoming call cancelled by caller', 'info');
                        }

                        // Hide modal and clean up
                        if (this.incomingCallModal) {
                            this.incomingCallModal.hide();
                        }
                        this.pendingInvitation = null;
                        this.publishCallState('idle');
                    }
                };

                // Reset the cancelled flag for new calls
                this.incomingCallCancelled = false;

                this.setupSessionHandlers(invitation);

                const callerInfo = invitation.remoteIdentity.displayName || invitation.remoteIdentity.uri.user;
                const callerNumber = invitation.remoteIdentity.uri.user;

                this.updateCallStatus('Incoming Call');
                this.updateRemoteParty(callerInfo);

                // Publish call state: ringing
                this.publishCallState('ringing');

                // Update modal content
                document.getElementById('incomingCallerName').textContent = callerInfo || 'Unknown Caller';
                document.getElementById('incomingCallerNumber').textContent = callerNumber || '-';

                // Dispose existing modal to prevent stacking issues
                if (this.incomingCallModal) {
                    this.incomingCallModal.dispose();
                    this.incomingCallModal = null;
                }

                // Show the incoming call modal
                this.incomingCallModal = new bootstrap.Modal(document.getElementById('incomingCallModal'));
                this.incomingCallModal.show();

                this.log(`Incoming call from: ${callerInfo}`, 'info');
            }

            acceptIncomingCall() {
                if (this.pendingInvitation) {
                    this.currentSession = this.pendingInvitation;
                    this.currentCallType = 'incoming';
                    this.pendingInvitation.accept({
                        sessionDescriptionHandlerOptions: {
                            constraints: { audio: true, video: false }
                        }
                    });

                    // Publish call state: in_call
                    this.publishCallState('in_call');

                    this.enableCallControls(true);
                    this.incomingCallModal.hide();
                    this.pendingInvitation = null;
                    this.log('Incoming call accepted', 'success');
                }
            }

            declineIncomingCall() {
                if (this.pendingInvitation) {
                    const callerNumber = this.pendingInvitation.remoteIdentity.uri.user;
                    this.pendingInvitation.reject();
                    this.incomingCallModal.hide();
                    this.pendingInvitation = null;

                    // Add declined call to history as missed
                    this.addCallToHistory('missed', callerNumber);

                    // Publish call state: idle
                    this.publishCallState('idle');

                    this.clearCall();
                    this.log('Incoming call declined', 'info');
                }
            }

            setupSessionHandlers(session) {
                session.stateChange.addListener((newState) => {
                    this.log(`Call state: ${newState}`, 'info');

                    switch (newState) {
                        case SIP.SessionState.Establishing:
                            this.updateCallStatus('Connecting...');
                            break;
                        case SIP.SessionState.Established:
                            this.updateCallStatus('Connected');
                            this.startCallTimer();

                            // Publish call state: in_call
                            this.publishCallState('in_call');

                            this.setupAudioHandling(session);

                            // Debug logging for audio streams
                            this.debugAudioState(session);

                            this.displayCustomHeaders(session);
                            break;
                        case SIP.SessionState.Terminated:
                            this.updateCallStatus('Call Ended');

                            // Publish call state: idle
                            this.publishCallState('idle');

                            this.clearCall();
                            break;
                    }
                });

                // Set up peer connection delegate when session description handler is available
                const setupPeerConnectionDelegate = () => {
                    if (session.sessionDescriptionHandler && session.sessionDescriptionHandler.peerConnection) {
                        session.sessionDescriptionHandler.peerConnection.ontrack = (event) => {
                            this.log('Remote audio stream received', 'success');
                            event.streams.forEach(stream => {
                                this.handleRemoteStream(stream);
                            });
                        };
                    }
                };

                // Try to set up immediately, or wait for the session description handler
                if (session.sessionDescriptionHandler) {
                    setupPeerConnectionDelegate();
                } else {
                    // Wait for the session description handler to be created
                    const checkForHandler = setInterval(() => {
                        if (session.sessionDescriptionHandler) {
                            clearInterval(checkForHandler);
                            setupPeerConnectionDelegate();
                        }
                    }, 100);
                }
            }

            setupAudioHandling(session) {
                const sessionDescriptionHandler = session.sessionDescriptionHandler;
                if (sessionDescriptionHandler && sessionDescriptionHandler.peerConnection) {
                    const pc = sessionDescriptionHandler.peerConnection;

                    pc.getRemoteStreams().forEach((stream) => {
                        this.handleRemoteStream(stream);
                    });
                }
            }

            handleRemoteStream(stream) {
                const audioContainer = document.getElementById('audioContainer');
                audioContainer.innerHTML = '<h6>Audio Streams</h6>';

                const audio = document.createElement('audio');
                audio.srcObject = stream;
                audio.autoplay = true;
                audio.controls = true;
                audio.id = 'remoteAudio';

                const label = document.createElement('div');
                label.textContent = 'Remote Audio Stream';
                label.className = 'small text-muted mb-1';

                audioContainer.appendChild(label);
                audioContainer.appendChild(audio);

                this.updateSpeakerVolume();
            }

            debugAudioState(session) {
                this.log('=== AUDIO DEBUG START ===', 'info');

                const sdh = session.sessionDescriptionHandler;
                if (!sdh) {
                    this.log('DEBUG: No sessionDescriptionHandler', 'error');
                    return;
                }

                // Check local media stream
                if (sdh.localMediaStream) {
                    const localStream = sdh.localMediaStream;
                    this.log(`DEBUG: Local stream ID: ${localStream.id}`, 'info');
                    this.log(`DEBUG: Local stream active: ${localStream.active}`, 'info');

                    const audioTracks = localStream.getAudioTracks();
                    this.log(`DEBUG: Local audio tracks count: ${audioTracks.length}`, 'info');

                    audioTracks.forEach((track, i) => {
                        this.log(`DEBUG: Local track[${i}] id: ${track.id}`, 'info');
                        this.log(`DEBUG: Local track[${i}] enabled: ${track.enabled}`, 'info');
                        this.log(`DEBUG: Local track[${i}] muted: ${track.muted}`, 'info');
                        this.log(`DEBUG: Local track[${i}] readyState: ${track.readyState}`, 'info');
                        this.log(`DEBUG: Local track[${i}] label: ${track.label}`, 'info');
                        if (track.getSettings) {
                            const settings = track.getSettings();
                            this.log(`DEBUG: Local track[${i}] deviceId: ${settings.deviceId}`, 'info');
                        }
                    });
                } else {
                    this.log('DEBUG: No localMediaStream!', 'error');
                }

                // Check peer connection
                const pc = sdh.peerConnection;
                if (pc) {
                    this.log(`DEBUG: PeerConnection state: ${pc.connectionState}`, 'info');
                    this.log(`DEBUG: ICE connection state: ${pc.iceConnectionState}`, 'info');
                    this.log(`DEBUG: ICE gathering state: ${pc.iceGatheringState}`, 'info');
                    this.log(`DEBUG: Signaling state: ${pc.signalingState}`, 'info');

                    // Check senders (our outgoing tracks)
                    const senders = pc.getSenders();
                    this.log(`DEBUG: RTP Senders count: ${senders.length}`, 'info');
                    senders.forEach((sender, i) => {
                        if (sender.track) {
                            this.log(`DEBUG: Sender[${i}] track kind: ${sender.track.kind}`, 'info');
                            this.log(`DEBUG: Sender[${i}] track enabled: ${sender.track.enabled}`, 'info');
                            this.log(`DEBUG: Sender[${i}] track readyState: ${sender.track.readyState}`, 'info');
                        } else {
                            this.log(`DEBUG: Sender[${i}] has no track!`, 'error');
                        }
                    });

                    // Check receivers (incoming tracks)
                    const receivers = pc.getReceivers();
                    this.log(`DEBUG: RTP Receivers count: ${receivers.length}`, 'info');
                    receivers.forEach((receiver, i) => {
                        if (receiver.track) {
                            this.log(`DEBUG: Receiver[${i}] track kind: ${receiver.track.kind}`, 'info');
                            this.log(`DEBUG: Receiver[${i}] track enabled: ${receiver.track.enabled}`, 'info');
                            this.log(`DEBUG: Receiver[${i}] track readyState: ${receiver.track.readyState}`, 'info');
                        }
                    });

                    // Log ICE candidates gathered
                    if (pc.localDescription) {
                        const sdp = pc.localDescription.sdp;
                        const candidateMatches = sdp.match(/a=candidate:.*/g);
                        this.log(`DEBUG: ICE candidates in local SDP: ${candidateMatches ? candidateMatches.length : 0}`, 'info');
                    }
                } else {
                    this.log('DEBUG: No PeerConnection!', 'error');
                }

                this.log('=== AUDIO DEBUG END ===', 'info');
            }

            extractCustomHeaders(session) {
                let headers = {};

                // Incoming call: INVITE request headers
                if (session.incomingInviteRequest) {
                    headers = session.incomingInviteRequest.message.headers;
                }
                // Outgoing call: 200 OK response headers from dialog
                else if (session._dialog && session._dialog.initialTransaction &&
                         session._dialog.initialTransaction.message) {
                    headers = session._dialog.initialTransaction.message.headers;
                }

                const customHeaders = {};
                for (const [name, values] of Object.entries(headers)) {
                    if (name.startsWith('X-')) {
                        customHeaders[name] = values.map(v => v.raw).join(', ');
                    }
                }
                return customHeaders;
            }

            displayCustomHeaders(session) {
                const customHeaders = this.extractCustomHeaders(session);
                const card = document.getElementById('customHeadersCard');
                const list = document.getElementById('customHeadersList');
                const noHeaders = document.getElementById('noCustomHeaders');
                const count = document.getElementById('customHeaderCount');

                list.innerHTML = '';
                const entries = Object.entries(customHeaders);

                card.classList.remove('d-none');

                if (entries.length > 0) {
                    noHeaders.classList.add('d-none');
                    count.textContent = entries.length;

                    entries.forEach(([name, value]) => {
                        const row = document.createElement('div');
                        row.className = 'mb-1';
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'header-name';
                        nameSpan.textContent = name + ':';
                        const valueSpan = document.createElement('span');
                        valueSpan.className = 'header-value';
                        valueSpan.textContent = ' ' + value;
                        row.appendChild(nameSpan);
                        row.appendChild(valueSpan);
                        list.appendChild(row);
                    });
                } else {
                    noHeaders.classList.remove('d-none');
                    count.textContent = '0';
                }
            }

            hangupCall() {
                // If in transfer mode, also hang up both sessions
                if (this.isTransferMode) {
                    // Hang up transfer target session
                    if (this.transferTargetSession) {
                        try {
                            if (this.transferTargetSession.state === SIP.SessionState.Established) {
                                this.transferTargetSession.bye();
                            } else if (this.transferTargetSession.state === SIP.SessionState.Establishing) {
                                this.transferTargetSession.cancel();
                            }
                        } catch (error) {
                            this.log(`Hangup transfer call error: ${error.message}`, 'error');
                        }
                    }

                    // Hang up primary session
                    if (this.primarySession) {
                        try {
                            if (this.primarySession.state === SIP.SessionState.Established) {
                                this.primarySession.bye();
                            }
                        } catch (error) {
                            this.log(`Hangup primary call error: ${error.message}`, 'error');
                        }
                    }

                    this.resetTransferState();
                } else if (this.currentSession) {
                    try {
                        if (this.currentSession.state === SIP.SessionState.Established) {
                            this.currentSession.bye();
                        } else if (this.currentSession.state === SIP.SessionState.Establishing) {
                            this.currentSession.cancel();
                        }
                    } catch (error) {
                        this.log(`Hangup error: ${error.message}`, 'error');
                    }
                }

                // Publish call state: idle
                this.publishCallState('idle');

                this.clearCall();
            }

            async toggleHold() {
                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    return;
                }

                try {
                    if (this.isOnHold) {
                        // Resume the call
                        const options = {
                            sessionDescriptionHandlerOptions: {
                                constraints: { audio: true, video: false }
                            }
                        };
                        await this.currentSession.invite(options);
                        this.isOnHold = false;
                        this.updateCallStatus('Connected');
                        document.getElementById('holdBtn').innerHTML = '<i class="bi bi-pause"></i> Hold';
                        this.log('Call resumed', 'info');
                    } else {
                        // Put the call on hold by sending re-INVITE with inactive audio
                        const options = {
                            sessionDescriptionHandlerOptions: {
                                hold: true
                            }
                        };
                        await this.currentSession.invite(options);
                        this.isOnHold = true;
                        this.updateCallStatus('On Hold');
                        document.getElementById('holdBtn').innerHTML = '<i class="bi bi-play"></i> Resume';
                        this.log('Call placed on hold', 'info');
                    }
                } catch (error) {
                    this.log(`Hold operation failed: ${error.message}`, 'error');
                    // If hold fails, try alternative method using session description handler
                    this.tryAlternativeHold();
                }
            }

            tryAlternativeHold() {
                try {
                    const sdh = this.currentSession.sessionDescriptionHandler;
                    if (sdh && sdh.peerConnection) {
                        const pc = sdh.peerConnection;
                        const senders = pc.getSenders();

                        if (this.isOnHold) {
                            // Resume - enable all tracks
                            senders.forEach(sender => {
                                if (sender.track) {
                                    sender.track.enabled = true;
                                }
                            });
                            this.isOnHold = false;
                            this.updateCallStatus('Connected');
                            document.getElementById('holdBtn').innerHTML = '<i class="bi bi-pause"></i> Hold';
                            this.log('Call resumed (alternative method)', 'info');
                        } else {
                            // Hold - disable all tracks
                            senders.forEach(sender => {
                                if (sender.track) {
                                    sender.track.enabled = false;
                                }
                            });
                            this.isOnHold = true;
                            this.updateCallStatus('On Hold');
                            document.getElementById('holdBtn').innerHTML = '<i class="bi bi-play"></i> Resume';
                            this.log('Call placed on hold (alternative method)', 'info');
                        }
                    }
                } catch (error) {
                    this.log(`Alternative hold method also failed: ${error.message}`, 'error');
                }
            }

            // Transfer Methods
            showTransferModal() {
                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    this.log('Cannot transfer: no active call', 'error');
                    return;
                }
                document.getElementById('transferTarget').value = '';
                this.transferModal = new bootstrap.Modal(document.getElementById('transferModal'));
                this.transferModal.show();
            }

            async blindTransfer() {
                const targetNumber = document.getElementById('transferTarget').value.trim();
                if (!targetNumber) {
                    this.log('Please enter a transfer target', 'error');
                    return;
                }

                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    this.log('Cannot transfer: no active call', 'error');
                    return;
                }

                try {
                    const sipDomain = document.getElementById('sipDomain').value;
                    const targetUri = SIP.UserAgent.makeURI(`sip:${targetNumber}@${sipDomain}`);
                    if (!targetUri) {
                        throw new Error('Invalid transfer target');
                    }

                    this.log(`Initiating blind transfer to: ${targetNumber}`);

                    // Use the refer method for blind transfer
                    await this.currentSession.refer(targetUri);

                    this.log('Blind transfer initiated', 'success');
                    this.transferModal.hide();

                    // The call will be terminated by the server after successful transfer
                } catch (error) {
                    this.log(`Blind transfer failed: ${error.message}`, 'error');
                }
            }

            async startAttendedTransfer() {
                const targetNumber = document.getElementById('transferTarget').value.trim();
                if (!targetNumber) {
                    this.log('Please enter a transfer target', 'error');
                    return;
                }

                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    this.log('Cannot transfer: no active call', 'error');
                    return;
                }

                // Get authorization header for JWT
                const authHeader = this.getAuthorizationHeader();
                if (!authHeader) {
                    this.log('Cannot make transfer call without JWT token', 'error');
                    return;
                }

                try {
                    // Store the primary call info
                    this.primarySession = this.currentSession;
                    this.primaryCallInfo = {
                        remoteParty: document.getElementById('remoteParty').textContent,
                        duration: document.getElementById('callDuration').textContent,
                        startTime: this.callStartTime
                    };

                    // Put the primary call on hold
                    if (!this.isOnHold) {
                        await this.toggleHold();
                    }

                    // Hide modal and set transfer mode
                    this.transferModal.hide();
                    this.isTransferMode = true;

                    // Switch to split view
                    this.showTransferSplitView(targetNumber);

                    // Make the consultation call
                    this.log(`Starting attended transfer - calling: ${targetNumber}`);

                    const sipDomain = document.getElementById('sipDomain').value;
                    const targetUri = SIP.UserAgent.makeURI(`sip:${targetNumber}@${sipDomain}`);
                    if (!targetUri) {
                        throw new Error('Invalid transfer target');
                    }

                    const inviter = new SIP.Inviter(this.ua, targetUri, {
                        extraHeaders: [
                            `Authorization: ${authHeader}`
                        ]
                    });
                    this.transferTargetSession = inviter;
                    this.currentSession = inviter;

                    this.setupTransferSessionHandlers(inviter, targetNumber);

                    await inviter.invite({
                        sessionDescriptionHandlerOptions: {
                            constraints: { audio: true, video: false }
                        }
                    });

                } catch (error) {
                    this.log(`Attended transfer failed: ${error.message}`, 'error');
                    this.cancelTransfer();
                }
            }

            setupTransferSessionHandlers(session, targetNumber) {
                session.stateChange.addListener((state) => {
                    this.log(`Transfer call state: ${state}`);

                    switch (state) {
                        case SIP.SessionState.Establishing:
                            document.getElementById('transferCallStatus').textContent = 'Calling...';
                            break;
                        case SIP.SessionState.Established:
                            document.getElementById('transferCallStatus').textContent = 'Connected';
                            this.startTransferCallTimer();
                            this.handleTransferCallRemoteStream(session);
                            this.log('Transfer consultation call connected', 'success');
                            break;
                        case SIP.SessionState.Terminated:
                            this.log('Transfer consultation call ended', 'info');
                            // Auto-resume primary call if transfer target hangs up
                            if (this.isTransferMode && this.primarySession) {
                                this.log('Transfer target disconnected - resuming primary call', 'info');
                                this.cancelTransfer();
                            }
                            break;
                    }
                });
            }

            handleTransferCallRemoteStream(session) {
                const remoteStream = new MediaStream();
                session.sessionDescriptionHandler.peerConnection.getReceivers().forEach(receiver => {
                    if (receiver.track) {
                        remoteStream.addTrack(receiver.track);
                    }
                });

                // Create audio element for transfer call
                const audioContainer = document.getElementById('audioContainer');
                const audio = document.createElement('audio');
                audio.id = 'transferAudio';
                audio.srcObject = remoteStream;
                audio.autoplay = true;
                audioContainer.appendChild(audio);
            }

            startTransferCallTimer() {
                this.transferCallStartTime = Date.now();
                this.transferCallTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.transferCallStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                    const seconds = (elapsed % 60).toString().padStart(2, '0');
                    document.getElementById('transferCallDuration').textContent = `${minutes}:${seconds}`;
                }, 1000);
            }

            showTransferSplitView(targetNumber) {
                // Hide single call view, show split view
                document.getElementById('singleCallView').classList.add('d-none');
                document.getElementById('transferSplitView').classList.remove('d-none');

                // Update primary call info
                document.getElementById('primaryCallParty').textContent = this.primaryCallInfo.remoteParty;
                document.getElementById('primaryCallDuration').textContent = this.primaryCallInfo.duration;

                // Update transfer call info
                document.getElementById('transferCallParty').textContent = targetNumber;
                document.getElementById('transferCallStatus').textContent = 'Calling...';
                document.getElementById('transferCallDuration').textContent = '00:00';

                // Disable transfer button while in transfer mode
                document.getElementById('transferBtn').disabled = true;
            }

            hideTransferSplitView() {
                // Show single call view, hide split view
                document.getElementById('singleCallView').classList.remove('d-none');
                document.getElementById('transferSplitView').classList.add('d-none');

                // Re-enable transfer button
                document.getElementById('transferBtn').disabled = false;
            }

            async completeAttendedTransfer() {
                if (!this.primarySession || !this.transferTargetSession) {
                    this.log('Cannot complete transfer: missing sessions', 'error');
                    return;
                }

                if (this.transferTargetSession.state !== SIP.SessionState.Established) {
                    this.log('Cannot complete transfer: consultation call not established', 'error');
                    return;
                }

                try {
                    this.log('Completing attended transfer...');

                    // Use REFER with the transfer target session for attended transfer
                    await this.primarySession.refer(this.transferTargetSession);

                    this.log('Attended transfer completed', 'success');

                    // Clean up
                    this.resetTransferState();
                } catch (error) {
                    this.log(`Attended transfer completion failed: ${error.message}`, 'error');
                }
            }

            async cancelTransfer() {
                this.log('Cancelling transfer...');

                try {
                    // Hang up the transfer target call if it exists
                    if (this.transferTargetSession) {
                        if (this.transferTargetSession.state === SIP.SessionState.Established) {
                            this.transferTargetSession.bye();
                        } else if (this.transferTargetSession.state === SIP.SessionState.Establishing) {
                            this.transferTargetSession.cancel();
                        }
                    }

                    // Remove transfer audio element
                    const transferAudio = document.getElementById('transferAudio');
                    if (transferAudio) {
                        transferAudio.remove();
                    }

                    // Clear transfer call timer
                    if (this.transferCallTimer) {
                        clearInterval(this.transferCallTimer);
                        this.transferCallTimer = null;
                    }

                    // Resume the primary call
                    if (this.primarySession && this.primarySession.state === SIP.SessionState.Established) {
                        this.currentSession = this.primarySession;

                        // Resume from hold if needed
                        if (this.isOnHold) {
                            await this.toggleHold();
                        }

                        this.log('Primary call resumed', 'success');
                    }
                } catch (error) {
                    this.log(`Error during transfer cancellation: ${error.message}`, 'error');
                }

                // Reset transfer state
                this.resetTransferState();
            }

            resetTransferState() {
                this.isTransferMode = false;
                this.primarySession = null;
                this.transferTargetSession = null;
                this.primaryCallInfo = null;

                if (this.transferCallTimer) {
                    clearInterval(this.transferCallTimer);
                    this.transferCallTimer = null;
                }

                // Hide split view
                this.hideTransferSplitView();

                // If no current session, clear the call
                if (!this.currentSession || this.currentSession.state === SIP.SessionState.Terminated) {
                    this.clearCall();
                }
            }

            sendDTMF(tone) {
                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    this.log('Cannot send DTMF: no active call', 'error');
                    return;
                }

                try {
                    const options = { duration: 100, gap: 50 };
                    this.currentSession.sessionDescriptionHandler.sendDtmf(tone, options);
                    this.log(`DTMF sent: ${tone}`, 'info');
                } catch (error) {
                    this.log(`DTMF failed: ${error.message}`, 'error');
                }
            }

            toggleMute() {
                if (!this.currentSession || this.currentSession.state !== SIP.SessionState.Established) {
                    return;
                }

                try {
                    const sessionDescriptionHandler = this.currentSession.sessionDescriptionHandler;
                    if (sessionDescriptionHandler.localMediaStream) {
                        const audioTracks = sessionDescriptionHandler.localMediaStream.getAudioTracks();
                        audioTracks.forEach(track => {
                            track.enabled = this.isMuted;
                        });

                        this.isMuted = !this.isMuted;

                        const muteBtn = document.getElementById('muteBtn');
                        if (this.isMuted) {
                            muteBtn.innerHTML = '<i class="bi bi-mic-mute"></i> Unmute';
                            muteBtn.classList.remove('btn-outline-secondary');
                            muteBtn.classList.add('btn-danger');
                        } else {
                            muteBtn.innerHTML = '<i class="bi bi-mic"></i> Mute';
                            muteBtn.classList.remove('btn-danger');
                            muteBtn.classList.add('btn-outline-secondary');
                        }

                        this.log(`Microphone ${this.isMuted ? 'muted' : 'unmuted'}`, 'info');
                    }
                } catch (error) {
                    this.log(`Mute operation failed: ${error.message}`, 'error');
                }
            }

            setSpeakerVolume(value) {
                const volumeValue = document.getElementById('volumeValue');
                volumeValue.textContent = `${value}%`;
                this.updateSpeakerVolume();
            }

            updateSpeakerVolume() {
                const volume = document.getElementById('speakerVolume').value / 100;
                const audio = document.getElementById('remoteAudio');
                if (audio) {
                    audio.volume = volume;
                }
            }

            setMicrophoneVolume(value) {
                // Note: Web browsers don't allow direct microphone volume control
                // This would need to be handled through audio processing
                this.log(`Microphone volume set to ${value}%`, 'info');
            }

            addDigit(digit) {
                const phoneNumberInput = document.getElementById('phoneNumber');
                phoneNumberInput.value += digit;
            }

            clearNumber() {
                const phoneNumberInput = document.getElementById('phoneNumber');
                phoneNumberInput.value = phoneNumberInput.value.slice(0, -1);
            }

            startCallTimer() {
                this.callStartTime = new Date();
                this.callTimer = setInterval(() => {
                    const duration = Math.floor((new Date() - this.callStartTime) / 1000);
                    const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                    const seconds = (duration % 60).toString().padStart(2, '0');
                    const timeStr = `${minutes}:${seconds}`;
                    document.getElementById('callDuration').textContent = timeStr;
                    // Update header duration
                    const headerDuration = document.getElementById('headerCallDuration');
                    if (headerDuration) {
                        headerDuration.textContent = timeStr;
                    }
                }, 1000);
            }

            clearCall() {
                if (this.callTimer) {
                    clearInterval(this.callTimer);
                    this.callTimer = null;
                }

                // Calculate call duration if there was an active call
                let duration = null;
                if (this.callStartTime && this.currentSession) {
                    duration = Math.floor((new Date() - this.callStartTime) / 1000);
                }

                // Add call to history if there was an active session (skip if already handled by onCancel)
                if (this.currentSession && document.getElementById('remoteParty').textContent !== '-' && !this.incomingCallCancelled) {
                    const remoteParty = document.getElementById('remoteParty').textContent;
                    const callStatus = document.getElementById('callStatus').textContent;

                    let callType = 'outgoing'; // Default assumption
                    if (callStatus === 'Incoming Call') {
                        callType = 'missed';
                    } else if (this.callStartTime) {
                        // If we have a start time, it was answered
                        callType = this.currentCallType || 'outgoing';
                    }

                    this.addCallToHistory(callType, remoteParty, duration);
                }

                // Reset the cancelled flag
                this.incomingCallCancelled = false;

                this.currentSession = null;
                this.currentCallType = null;
                this.callStartTime = null;
                this.isOnHold = false;
                this.isMuted = false;

                this.updateCallStatus('Idle');
                this.updateRemoteParty('-');
                document.getElementById('callDuration').textContent = '00:00';
                this.enableCallControls(false);

                // Reset audio controls
                document.getElementById('muteBtn').innerHTML = '<i class="bi bi-mic"></i> Mute';
                document.getElementById('muteBtn').classList.remove('btn-danger');
                document.getElementById('muteBtn').classList.add('btn-outline-secondary');
                document.getElementById('holdBtn').innerHTML = '<i class="bi bi-pause"></i> Hold';

                // Clear audio container
                const audioContainer = document.getElementById('audioContainer');
                audioContainer.innerHTML = '';

                // Hide custom SIP headers card
                document.getElementById('customHeadersCard').classList.add('d-none');
                document.getElementById('customHeadersList').innerHTML = '';

                // Reset header call info
                const headerDuration = document.getElementById('headerCallDuration');
                if (headerDuration) headerDuration.textContent = '';
                const headerRemoteParty = document.getElementById('headerRemoteParty');
                if (headerRemoteParty) headerRemoteParty.textContent = '';

                // Ensure incoming call modal is hidden
                if (this.incomingCallModal) {
                    this.incomingCallModal.hide();
                }

                this.log('Call cleared', 'info');
            }

            updateConnectionStatus(status) {
                const statusElement = document.getElementById('connectionStatus');
                const statusHeader = document.getElementById('statusHeader');
                const statusDot = document.getElementById('statusDot');

                statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);

                // Update header styling
                statusHeader.className = 'status-header';
                statusDot.className = 'status-dot';

                if (status === 'connected') {
                    statusHeader.classList.add('header-connected');
                    statusDot.classList.add('dot-connected');
                } else if (status === 'connecting') {
                    statusHeader.classList.add('header-connecting');
                    statusDot.classList.add('dot-connecting');
                } else {
                    statusHeader.classList.add('header-disconnected');
                    statusDot.classList.add('dot-disconnected');
                }

                document.getElementById('connectBtn').disabled = status === 'connected' || status === 'connecting';
                document.getElementById('disconnectBtn').disabled = status === 'disconnected';
            }

            updateRegistrationStatus(status, type = 'info') {
                const elem = document.getElementById('registrationStatus');
                elem.textContent = status;

                // Use registration-badge class for visibility on header
                elem.className = 'registration-badge ms-2';

                if (status) {
                    elem.style.display = 'inline';
                } else {
                    elem.style.display = 'none';
                }
            }

            updateStatusBarStyle(type) {
                // Legacy function - header styling is now handled by updateConnectionStatus
            }

            updateCallStatus(status) {
                document.getElementById('callStatus').textContent = status;
            }

            updateRemoteParty(party) {
                document.getElementById('remoteParty').textContent = party;
                // Update header
                const headerRemoteParty = document.getElementById('headerRemoteParty');
                if (headerRemoteParty) {
                    headerRemoteParty.textContent = party !== '-' ? party : '';
                }
            }

            updateHeaderCallDuration() {
                const headerDuration = document.getElementById('headerCallDuration');
                if (headerDuration && this.callStartTime) {
                    const duration = Math.floor((new Date() - this.callStartTime) / 1000);
                    const minutes = Math.floor(duration / 60).toString().padStart(2, '0');
                    const seconds = (duration % 60).toString().padStart(2, '0');
                    headerDuration.textContent = `${minutes}:${seconds}`;
                }
            }

            enableControls(enabled) {
                document.getElementById('callBtn').disabled = !enabled;
            }

            enableCallControls(enabled) {
                document.getElementById('hangupBtn').disabled = !enabled;
                document.getElementById('holdBtn').disabled = !enabled;
                // Transfer button enabled only when on call and not already in transfer mode
                document.getElementById('transferBtn').disabled = !enabled || this.isTransferMode;
                document.querySelectorAll('.dtmf-btn').forEach(btn => {
                    btn.disabled = !enabled;
                });

                // Show/hide in-call controls and call info card
                const inCallControls = document.getElementById('inCallControls');
                const callInfoCard = document.getElementById('callInfoCard');
                const headerCallInfo = document.getElementById('headerCallInfo');
                const statusHeader = document.getElementById('statusHeader');

                if (enabled) {
                    inCallControls.classList.remove('d-none');
                    callInfoCard.classList.remove('d-none');
                    callInfoCard.classList.add('on-call');
                    headerCallInfo.classList.remove('d-none');
                    statusHeader.classList.remove('header-connected');
                    statusHeader.classList.add('header-in-call');
                } else {
                    inCallControls.classList.add('d-none');
                    callInfoCard.classList.add('d-none');
                    callInfoCard.classList.remove('on-call');
                    headerCallInfo.classList.add('d-none');
                    if (this.isConnected) {
                        statusHeader.classList.remove('header-in-call');
                        statusHeader.classList.add('header-connected');
                    }
                }
            }

            showError(message) {
                const errorDiv = document.getElementById('errorMessage');
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';

                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000);
            }

            clearLog() {
                const debugLog = document.getElementById('debugLog');
                debugLog.innerHTML = '<div class="text-muted">Debug info appears here...</div>';

                const debugLogMobile = document.getElementById('debugLogMobile');
                if (debugLogMobile) {
                    debugLogMobile.innerHTML = '<div class="text-muted">Debug info appears here...</div>';
                }
            }

            async testConnection() {
                const wsServer = document.getElementById('wsServer').value;

                if (!wsServer) {
                    this.log('Please enter a WebSocket server URL to test', 'error');
                    return;
                }

                this.log('Starting connection diagnostics...');
                this.log(`Testing connection to: ${wsServer}`);

                try {
                    const url = new URL(wsServer);
                    this.log(`URL format valid: ${url.protocol}//${url.host}${url.pathname}`, 'success');

                    if (url.protocol === 'ws:') {
                        this.log('Using unencrypted WebSocket (ws://)', 'info');
                    } else if (url.protocol === 'wss:') {
                        this.log('Using encrypted WebSocket (wss://)', 'success');
                    } else {
                        this.log(`Invalid protocol: ${url.protocol} (should be ws: or wss:)`, 'error');
                        return;
                    }
                } catch (error) {
                    this.log(`Invalid URL format: ${error.message}`, 'error');
                    return;
                }

                this.log('Testing WebSocket connectivity...');

                try {
                    const testSocket = new WebSocket(wsServer);
                    let connectionResult = false;
                    let closeCode = null;
                    let closeReason = '';

                    const timeout = setTimeout(() => {
                        if (!connectionResult) {
                            this.log('Connection timeout (10 seconds) - server may be unreachable', 'error');
                            testSocket.close();
                        }
                    }, 10000);

                    testSocket.onopen = () => {
                        connectionResult = true;
                        clearTimeout(timeout);
                        this.log('WebSocket connection established successfully', 'success');
                        this.log('Connection details:', 'info');
                        this.log(`- Ready State: ${testSocket.readyState}`, 'info');
                        this.log(`- Protocol: ${testSocket.protocol || 'none'}`, 'info');
                        this.log(`- Extensions: ${testSocket.extensions || 'none'}`, 'info');

                        setTimeout(() => {
                            this.log('Closing test connection...', 'info');
                            testSocket.close(1000, 'Test complete');
                        }, 1000);
                    };

                    testSocket.onclose = (event) => {
                        clearTimeout(timeout);
                        closeCode = event.code;
                        closeReason = event.reason;

                        if (connectionResult) {
                            this.log(`Test connection closed normally (code: ${closeCode})`, 'success');
                            this.log('WebSocket server is reachable and accepting connections', 'success');
                            this.log('If SIP connection still fails, check JWT token validity and server RFC 8898 support', 'info');
                        } else {
                            this.log(`Connection failed (code: ${closeCode})`, 'error');
                            this.diagnosePlatformProblems(closeCode, closeReason, wsServer);
                        }
                    };

                    testSocket.onerror = (error) => {
                        clearTimeout(timeout);
                        this.log('WebSocket error occurred during test', 'error');
                        this.log('This usually indicates network or server issues', 'error');
                    };

                } catch (error) {
                    this.log(`Failed to create test WebSocket: ${error.message}`, 'error');
                    this.log('This may indicate browser restrictions or invalid URL', 'error');
                }
            }

            diagnosePlatformProblems(closeCode, closeReason, wsServer) {
                this.log('Diagnosing connection problems...', 'info');

                switch (closeCode) {
                    case 1006:
                        this.log('Connection closed abnormally (1006)', 'error');
                        this.log('Check: server running, correct endpoint path, firewall, network', 'error');
                        break;
                    case 1015:
                        this.log('TLS handshake failed (1015)', 'error');
                        this.log('Check SSL certificate or try ws:// for testing', 'error');
                        break;
                    default:
                        this.log(`Unexpected close code: ${closeCode}`, 'error');
                        if (closeReason) {
                            this.log(`Close reason: ${closeReason}`, 'error');
                        }
                }

                const url = new URL(wsServer);
                this.log(`Verify server is running on port ${url.port || (url.protocol === 'wss:' ? '443' : '80')}`, 'info');
                this.log(`Check WebSocket endpoint path: ${url.pathname}`, 'info');
            }

            loadSettings() {
                try {
                    const savedSettings = localStorage.getItem('sipphone-jwt-settings');
                    if (savedSettings) {
                        const settings = JSON.parse(savedSettings);

                        if (settings.wsServer) document.getElementById('wsServer').value = settings.wsServer;
                        if (settings.sipUser) document.getElementById('sipUser').value = settings.sipUser;
                        if (settings.jwtToken) document.getElementById('jwtToken').value = settings.jwtToken;
                        if (settings.sipDomain) document.getElementById('sipDomain').value = settings.sipDomain;

                        if (settings.presenceEnabled !== undefined) {
                            document.getElementById('presenceEnabled').checked = settings.presenceEnabled;
                            this.togglePresenceSettings(settings.presenceEnabled);
                        }
                        if (settings.sipInstanceEnabled !== undefined) {
                            document.getElementById('sipInstanceEnabled').checked = settings.sipInstanceEnabled;
                        }
                        if (settings.correlationIdEnabled !== undefined) {
                            document.getElementById('correlationIdEnabled').checked = settings.correlationIdEnabled;
                        }
                        if (settings.presenceSubscriptions) document.getElementById('presenceSubscriptions').value = settings.presenceSubscriptions;
                        if (settings.presenceExpires) document.getElementById('presenceExpires').value = settings.presenceExpires;
                        if (settings.publishExpires) document.getElementById('publishExpires').value = settings.publishExpires;
                        if (settings.turnEnabled !== undefined) {
                            document.getElementById('turnEnabled').checked = settings.turnEnabled;
                            this.toggleTurnSettings(settings.turnEnabled);
                        }
                        if (settings.turnServer) document.getElementById('turnServer').value = settings.turnServer;
                        if (settings.turnUsername) document.getElementById('turnUsername').value = settings.turnUsername;
                        if (settings.turnCredential) document.getElementById('turnCredential').value = settings.turnCredential;

                        // Load new settings
                        if (settings.isDND) {
                            this.isDND = settings.isDND;
                            document.getElementById('dndToggle').checked = settings.isDND;
                            this.toggleDND(settings.isDND);
                        }
                        if (settings.selectedMicId) this.selectedMicId = settings.selectedMicId;
                        if (settings.selectedSpeakerId) this.selectedSpeakerId = settings.selectedSpeakerId;

                        this.log('Settings loaded from localStorage', 'success');
                    }
                } catch (error) {
                    this.log(`Failed to load settings: ${error.message}`, 'error');
                }
            }

            saveSettings() {
                try {
                    const settings = {
                        wsServer: document.getElementById('wsServer').value,
                        sipUser: document.getElementById('sipUser').value,
                        jwtToken: document.getElementById('jwtToken').value,
                        sipDomain: document.getElementById('sipDomain').value,
                        presenceEnabled: document.getElementById('presenceEnabled').checked,
                        sipInstanceEnabled: document.getElementById('sipInstanceEnabled').checked,
                        correlationIdEnabled: document.getElementById('correlationIdEnabled').checked,
                        presenceSubscriptions: document.getElementById('presenceSubscriptions').value,
                        presenceExpires: document.getElementById('presenceExpires').value,
                        publishExpires: document.getElementById('publishExpires').value,
                        turnEnabled: document.getElementById('turnEnabled').checked,
                        turnServer: document.getElementById('turnServer').value,
                        turnUsername: document.getElementById('turnUsername').value,
                        turnCredential: document.getElementById('turnCredential').value,
                        // New settings
                        isDND: this.isDND,
                        selectedMicId: this.selectedMicId,
                        selectedSpeakerId: this.selectedSpeakerId
                    };

                    localStorage.setItem('sipphone-jwt-settings', JSON.stringify(settings));
                } catch (error) {
                    this.log(`Failed to save settings: ${error.message}`, 'error');
                }
            }

            loadConfigFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);

                        if (config.server) document.getElementById('wsServer').value = config.server;
                        if (config.sip_user) document.getElementById('sipUser').value = config.sip_user;
                        if (config.jwt_token) document.getElementById('jwtToken').value = config.jwt_token;
                        if (config.domain) document.getElementById('sipDomain').value = config.domain;
                        if (config.correlationIdEnabled !== undefined) {
                            document.getElementById('correlationIdEnabled').checked = config.correlationIdEnabled;
                        }

                        this.saveSettings();
                        this.log('Configuration loaded from file', 'success');
                    } catch (err) {
                        this.log(`Failed to parse config file: ${err.message}`, 'error');
                    }
                };
                reader.readAsText(file);

                event.target.value = '';
            }

            saveConfigFile() {
                try {
                    const config = {
                        server: document.getElementById('wsServer').value,
                        sip_user: document.getElementById('sipUser').value,
                        jwt_token: document.getElementById('jwtToken').value,
                        domain: document.getElementById('sipDomain').value
                    };

                    // Add optional settings if configured
                    if (document.getElementById('presenceEnabled').checked) {
                        config.presenceEnabled = true;
                        config.presenceSubscriptions = document.getElementById('presenceSubscriptions').value;
                        config.presenceExpires = document.getElementById('presenceExpires').value;
                        config.publishExpires = document.getElementById('publishExpires').value;
                    }

                    if (document.getElementById('turnEnabled').checked) {
                        config.turnEnabled = true;
                        config.turnServer = document.getElementById('turnServer').value;
                        config.turnUsername = document.getElementById('turnUsername').value;
                        config.turnCredential = document.getElementById('turnCredential').value;
                    }

                    config.sipInstanceEnabled = document.getElementById('sipInstanceEnabled').checked;
                    config.correlationIdEnabled = document.getElementById('correlationIdEnabled').checked;

                    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'softphone-config.json';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    this.log('Configuration saved to file', 'success');
                } catch (error) {
                    this.log(`Failed to save config file: ${error.message}`, 'error');
                }
            }

            loadCallHistory() {
                try {
                    const savedHistory = localStorage.getItem('sipphone-jwt-call-history');
                    if (savedHistory) {
                        this.callHistory = JSON.parse(savedHistory);
                        this.renderCallHistory();
                        this.log('Call history loaded from localStorage', 'success');
                    }
                } catch (error) {
                    this.log(`Failed to load call history: ${error.message}`, 'error');
                    this.callHistory = [];
                }
            }

            saveCallHistory() {
                try {
                    localStorage.setItem('sipphone-jwt-call-history', JSON.stringify(this.callHistory));
                } catch (error) {
                    this.log(`Failed to save call history: ${error.message}`, 'error');
                }
            }

            loadMissedCallCount() {
                try {
                    const savedCount = localStorage.getItem('sipphone-jwt-missed-call-count');
                    if (savedCount) {
                        this.missedCallCount = parseInt(savedCount, 10) || 0;
                        this.updateMissedCallBadge();
                    }
                } catch (error) {
                    this.log(`Failed to load missed call count: ${error.message}`, 'error');
                    this.missedCallCount = 0;
                }
            }

            saveMissedCallCount() {
                try {
                    localStorage.setItem('sipphone-jwt-missed-call-count', this.missedCallCount.toString());
                } catch (error) {
                    this.log(`Failed to save missed call count: ${error.message}`, 'error');
                }
            }

            incrementMissedCallCount() {
                this.missedCallCount++;
                this.saveMissedCallCount();
                this.updateMissedCallBadge();
            }

            clearMissedCallCount() {
                this.missedCallCount = 0;
                this.saveMissedCallCount();
                this.updateMissedCallBadge();
                this.log('Missed call count cleared', 'info');
            }

            updateMissedCallBadge() {
                const badge = document.getElementById('missedCallBadge');
                const clearBtn = document.getElementById('clearMissedBtn');
                const badgeMobile = document.getElementById('missedCallBadgeMobile');
                const badgeOffcanvas = document.getElementById('missedCallBadgeOffcanvas');
                const clearBtnMobile = document.getElementById('clearMissedBtnMobile');

                const count = this.missedCallCount > 99 ? '99+' : this.missedCallCount;

                if (this.missedCallCount > 0) {
                    badge.textContent = count;
                    badge.style.display = 'inline';
                    clearBtn.style.display = 'inline-block';

                    if (badgeMobile) {
                        badgeMobile.textContent = count;
                        badgeMobile.style.display = 'inline';
                    }
                    if (badgeOffcanvas) {
                        badgeOffcanvas.textContent = count;
                        badgeOffcanvas.style.display = 'inline';
                    }
                    if (clearBtnMobile) {
                        clearBtnMobile.style.display = 'inline-block';
                    }
                } else {
                    badge.style.display = 'none';
                    clearBtn.style.display = 'none';

                    if (badgeMobile) badgeMobile.style.display = 'none';
                    if (badgeOffcanvas) badgeOffcanvas.style.display = 'none';
                    if (clearBtnMobile) clearBtnMobile.style.display = 'none';
                }
            }

            addCallToHistory(type, number, duration = null, status = 'completed') {
                const call = {
                    id: Date.now(),
                    type: type, // 'outgoing', 'incoming', 'missed'
                    number: number,
                    duration: duration,
                    status: status,
                    timestamp: new Date().toISOString()
                };

                this.callHistory.unshift(call); // Add to beginning
                if (this.callHistory.length > 100) {
                    this.callHistory = this.callHistory.slice(0, 100); // Keep only last 100 calls
                }

                // Increment missed call counter for missed calls
                if (type === 'missed') {
                    this.incrementMissedCallCount();
                }

                this.saveCallHistory();
                this.renderCallHistory();
            }

            renderCallHistory() {
                const historyContainer = document.getElementById('callHistoryList');

                if (this.callHistory.length === 0) {
                    historyContainer.innerHTML = '<div class="text-muted text-center small">No calls yet</div>';
                    return;
                }

                let historyHtml = '';
                this.callHistory.forEach(call => {
                    const date = new Date(call.timestamp);
                    const timeStr = date.toLocaleTimeString();
                    const dateStr = date.toLocaleDateString();

                    let iconClass = 'bi-telephone';
                    let iconColor = 'text-primary';
                    let typeText = call.type;

                    switch (call.type) {
                        case 'outgoing':
                            iconClass = 'bi-telephone-outbound';
                            iconColor = 'text-success';
                            typeText = 'Outgoing';
                            break;
                        case 'incoming':
                            iconClass = 'bi-telephone-inbound';
                            iconColor = 'text-info';
                            typeText = 'Incoming';
                            break;
                        case 'missed':
                            iconClass = 'bi-telephone-x';
                            iconColor = 'text-danger';
                            typeText = 'Missed';
                            break;
                    }

                    const durationStr = call.duration ? this.formatDuration(call.duration) : '-';
                    const isFav = this.isFavorite(call.number);
                    const starClass = isFav ? 'bi-star-fill text-warning' : 'bi-star';
                    const starAction = isFav ? '' : `onclick="softphone.addToFavorites('${call.number}')"`;

                    historyHtml += `
                        <div class="d-flex justify-content-between align-items-center border-bottom py-2">
                            <div class="d-flex align-items-center">
                                <i class="bi ${iconClass} ${iconColor} me-2"></i>
                                <div>
                                    <div class="fw-bold small">${call.number}</div>
                                    <small class="text-muted">${typeText}  ${durationStr}</small>
                                </div>
                            </div>
                            <div class="d-flex align-items-center">
                                <button class="btn btn-sm btn-link p-0 me-2" ${starAction} title="${isFav ? 'In favorites' : 'Add to favorites'}">
                                    <i class="bi ${starClass}"></i>
                                </button>
                                <button class="btn btn-sm btn-link p-0 text-success" onclick="document.getElementById('phoneNumber').value='${call.number}'; softphone.makeCall();" title="Call">
                                    <i class="bi bi-telephone-fill"></i>
                                </button>
                            </div>
                        </div>
                    `;
                });

                historyContainer.innerHTML = historyHtml;

                // Sync with mobile history list
                const historyContainerMobile = document.getElementById('callHistoryListMobile');
                if (historyContainerMobile) {
                    historyContainerMobile.innerHTML = historyHtml || '<div class="text-muted text-center small">No calls yet</div>';
                }
            }

            formatDuration(seconds) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
            }

            clearCallHistory() {
                if (confirm('Are you sure you want to clear all call history?')) {
                    this.callHistory = [];
                    this.saveCallHistory();
                    this.renderCallHistory();
                    this.log('Call history cleared', 'info');
                }
            }

            // ==================== Presence & BLF Module ====================

            initPresence() {
                this.presenceEnabled = true;
                this.publishExpires = parseInt(document.getElementById('publishExpires').value) || 300;
                this.presenceExpires = parseInt(document.getElementById('presenceExpires').value) || 600;

                const subsInput = document.getElementById('presenceSubscriptions').value;
                this.watchedExtensions = subsInput ? subsInput.split(',').map(e => e.trim()).filter(e => e) : [];

                this.log('Initialising presence features', 'info');
                this.log(`Publish expires: ${this.publishExpires}s, Presence expires: ${this.presenceExpires}s`, 'info');
                this.log(`Watching extensions: ${this.watchedExtensions.join(', ') || 'none'}`, 'info');

                // Publish initial presence: open/idle
                this.publishBasic('open');
                this.publishCallState('idle');

                // Subscribe to watched extensions
                this.subscribeToPresence();

                this.updatePresenceUI();
            }

            cleanupPresence() {
                this.log('Cleaning up presence subscriptions', 'info');

                // Clear timers
                if (this.publishTimer) {
                    clearTimeout(this.publishTimer);
                    this.publishTimer = null;
                }

                this.subscriptionTimers.forEach((timer) => {
                    clearTimeout(timer);
                });
                this.subscriptionTimers.clear();

                // Unsubscribe all
                this.activeSubscribers.forEach((subscriber, aor) => {
                    try {
                        subscriber.unsubscribe();
                    } catch (error) {
                        this.log(`Failed to unsubscribe ${aor}: ${error.message}`, 'error');
                    }
                });

                this.activeSubscribers.clear();
                this.presenceStates.clear();
                this.presenceEnabled = false;

                this.updatePresenceUI();
            }

            publishBasic(state) {
                if (!this.isRegistered || !this.presenceEnabled) {
                    return;
                }

                this.myPresenceState = state;
                this.log(`Publishing basic presence: ${state}`, 'info');

                const pidf = this.buildPIDFDocument(state, this.myCallState);
                this.sendPublish(pidf, 'application/pidf+xml');
            }

            publishCallState(callState) {
                if (!this.isRegistered || !this.presenceEnabled) {
                    return;
                }

                this.myCallState = callState;
                this.log(`Publishing call state: ${callState}`, 'info');

                const pidf = this.buildPIDFDocument(this.myPresenceState, callState);
                this.sendPublish(pidf, 'application/pidf+xml');
            }

            buildPIDFDocument(basicState, callState) {
                const sipUser = document.getElementById('sipUser').value;
                const sipDomain = document.getElementById('sipDomain').value;
                const entity = `sip:${sipUser}@${sipDomain}`;
                const timestamp = new Date().toISOString();

                // Map call state to RPID activity
                let activity = '<rpid:unknown/>';
                if (callState === 'in_call') {
                    activity = '<rpid:on-the-phone/>';
                } else if (callState === 'ringing') {
                    activity = '<rpid:busy/>';
                } else if (callState === 'idle') {
                    activity = '<rpid:available/>';
                }

                return `<?xml version="1.0" encoding="UTF-8"?>
<presence xmlns="urn:ietf:params:xml:ns:pidf"
          xmlns:rpid="urn:ietf:params:xml:ns:pidf:rpid"
          xmlns:dm="urn:ietf:params:xml:ns:pidf:data-model"
          entity="${entity}">
  <tuple id="t1">
    <status>
      <basic>${basicState}</basic>
    </status>
    <timestamp>${timestamp}</timestamp>
  </tuple>
  <dm:person id="p1">
    <rpid:activities>
      ${activity}
    </rpid:activities>
  </dm:person>
</presence>`;
            }

            sendPublish(body, contentType) {
                if (!this.ua) {
                    return;
                }

                try {
                    const sipUser = document.getElementById('sipUser').value;
                    const sipDomain = document.getElementById('sipDomain').value;
                    const targetUri = SIP.UserAgent.makeURI(`sip:${sipUser}@${sipDomain}`);

                    // Prepare extra headers as array of strings
                    const extraHeaders = [
                        'Event: presence',
                        'Expires: ' + this.publishExpires.toString()
                    ];

                    // Add JWT Bearer token
                    const authHeader = this.getAuthorizationHeader();
                    if (authHeader) {
                        extraHeaders.push('Authorization: ' + authHeader);
                    }

                    // Prepare body object with proper structure for SIP.js
                    const bodyObj = {
                        contentDisposition: 'render',
                        contentType: contentType,
                        content: body
                    };

                    // Create PUBLISH request with correct parameter order
                    const request = this.ua.userAgentCore.makeOutgoingRequestMessage(
                        'PUBLISH',
                        targetUri,
                        this.ua.configuration.uri,
                        targetUri,
                        {},           // options (5th parameter)
                        extraHeaders, // extraHeaders array (6th parameter)
                        bodyObj       // body object (7th parameter)
                    );

                    // Send via user agent core
                    this.ua.userAgentCore.request(request);

                    this.log('PUBLISH sent with Bearer token', 'success');

                    // Schedule refresh at 80% of expiry
                    this.schedulePublishRefresh();

                    // Update UI
                    const badge = document.getElementById('myPresenceStatus');
                    if (badge) {
                        badge.textContent = `${this.myPresenceState} (${this.myCallState})`;
                        badge.className = 'badge ms-2 ' + (this.myPresenceState === 'open' ? 'bg-success' : 'bg-secondary');
                    }

                } catch (error) {
                    this.log(`Failed to send PUBLISH: ${error.message}`, 'error');
                }
            }

            schedulePublishRefresh() {
                if (this.publishTimer) {
                    clearTimeout(this.publishTimer);
                }

                // Refresh at 80% of expiry
                const refreshInterval = this.publishExpires * 800;
                this.publishTimer = setTimeout(() => {
                    this.log('Refreshing PUBLISH', 'info');
                    this.publishBasic(this.myPresenceState);
                }, refreshInterval);
            }

            subscribeToPresence() {
                if (!this.ua || !this.isRegistered) {
                    return;
                }

                const sipDomain = document.getElementById('sipDomain').value;

                this.watchedExtensions.forEach(ext => {
                    const aor = `sip:${ext}@${sipDomain}`;

                    // Avoid duplicate subscriptions
                    if (this.activeSubscribers.has(aor)) {
                        this.log(`Already subscribed to ${aor}`, 'info');
                        return;
                    }

                    this.log(`Subscribing to presence for ${aor}`, 'info');

                    try {
                        const targetUri = SIP.UserAgent.makeURI(aor);
                        if (!targetUri) {
                            this.log(`Invalid URI: ${aor}`, 'error');
                            return;
                        }

                        // Get authorization header for SUBSCRIBE
                        const authHeader = this.getAuthorizationHeader();
                        const extraHeaders = authHeader ? [`Authorization: ${authHeader}`] : [];

                        // Subscribe to dialog event (primary for BLF) with Bearer token
                        const subscriber = new SIP.Subscriber(this.ua, targetUri, 'dialog', {
                            expires: this.presenceExpires,
                            extraHeaders: extraHeaders
                        });

                        // Handle subscription state changes
                        subscriber.stateChange.addListener((newState) => {
                            this.log(`Subscription to ${ext}: ${newState}`, 'info');

                            if (newState === SIP.SubscriptionState.Subscribed) {
                                this.log(`Subscribed to ${ext}`, 'success');

                                // Schedule refresh at 80% of expires
                                const refreshInterval = this.presenceExpires * 800;
                                const timer = setTimeout(() => {
                                    this.log(`Refreshing subscription to ${ext}`, 'info');
                                    // Refresh uses same extraHeaders from constructor
                                    subscriber.subscribe().catch(error => {
                                        this.log(`Subscription refresh failed for ${ext}: ${error.message}`, 'error');
                                    });
                                }, refreshInterval);

                                this.subscriptionTimers.set(aor, timer);

                            } else if (newState === SIP.SubscriptionState.Terminated) {
                                this.log(`Subscription to ${ext} terminated`, 'error');
                                this.activeSubscribers.delete(aor);

                                const timer = this.subscriptionTimers.get(aor);
                                if (timer) {
                                    clearTimeout(timer);
                                    this.subscriptionTimers.delete(aor);
                                }

                                this.updatePresenceUI();
                            }
                        });

                        // Handle NOTIFY
                        subscriber.delegate = {
                            onNotify: (notification) => {
                                this.log(`NOTIFY received from ${ext}`, 'info');

                                const contentType = notification.request.getHeader('Content-Type');
                                const body = notification.request.body;

                                this.log(`NOTIFY Content-Type: ${contentType}`, 'info');
                                this.log(`NOTIFY body length: ${body ? body.length : 0} bytes`, 'info');

                                let parsedState = null;

                                // Handle empty NOTIFY (no active dialogs = idle)
                                if (!body || body.length === 0) {
                                    this.log(`Empty NOTIFY body - assuming idle state`, 'info');
                                    parsedState = {
                                        aor: aor,
                                        registered: true,
                                        callState: 'idle',
                                        direction: 'unknown',
                                        remoteParty: null,
                                        updatedAt: Date.now(),
                                        source: 'dialog'
                                    };
                                } else if (contentType && contentType.includes('dialog-info+xml')) {
                                    this.log(`Parsing as dialog-info XML`, 'info');
                                    parsedState = this.parseDialogInfo(body, aor);
                                } else if (contentType && contentType.includes('pidf+xml')) {
                                    this.log(`Parsing as PIDF XML`, 'info');
                                    parsedState = this.parsePIDF(body, aor);
                                } else {
                                    this.log(`Unknown Content-Type for NOTIFY: ${contentType}`, 'error');
                                }

                                if (parsedState) {
                                    this.log(`Parsed state: ${JSON.stringify(parsedState)}`, 'info');
                                    this.presenceStates.set(aor, parsedState);
                                    this.log(`Presence states size: ${this.presenceStates.size}`, 'info');
                                    this.updatePresenceUI();
                                } else {
                                    this.log(`Failed to parse NOTIFY body`, 'error');
                                }

                                // Accept the NOTIFY
                                notification.accept();
                            }
                        };

                        // Send SUBSCRIBE (Bearer token already in constructor extraHeaders)
                        subscriber.subscribe().then(() => {
                            this.log(`SUBSCRIBE sent for ${ext} with Bearer token`, 'success');
                            this.activeSubscribers.set(aor, subscriber);
                            this.updatePresenceUI();
                        }).catch(error => {
                            this.log(`SUBSCRIBE failed for ${ext}: ${error.message}`, 'error');

                            // Handle 423 Interval Too Brief
                            if (error.message && error.message.includes('423')) {
                                this.log('Server requires longer expires interval (423 Interval Too Brief)', 'error');
                                this.log('Please increase the Presence Expires value and reconnect', 'error');
                            }
                        });

                    } catch (error) {
                        this.log(`Failed to create subscription for ${ext}: ${error.message}`, 'error');
                    }
                });
            }

            parseDialogInfo(xmlBody, aor) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xmlBody, 'text/xml');

                    // Handle parsing errors
                    if (doc.documentElement.nodeName === 'parsererror') {
                        this.log('Failed to parse dialog-info XML', 'error');
                        return null;
                    }

                    const dialogInfo = doc.documentElement;
                    const dialogs = dialogInfo.getElementsByTagName('dialog');

                    let callState = 'idle';
                    let direction = 'unknown';
                    let remoteParty = null;
                    let registered = null;

                    if (dialogs.length === 0) {
                        callState = 'idle';
                    } else {
                        // Process first active dialog
                        for (let i = 0; i < dialogs.length; i++) {
                            const dialog = dialogs[i];
                            const stateElem = dialog.getElementsByTagName('state')[0];
                            const directionAttr = dialog.getAttribute('direction');

                            if (stateElem) {
                                const state = stateElem.textContent.trim().toLowerCase();

                                if (state === 'confirmed' || state === 'early') {
                                    callState = 'in_call';
                                    direction = directionAttr || 'unknown';

                                    // Try to extract remote party
                                    const remoteElem = dialog.getElementsByTagName('remote')[0];
                                    if (remoteElem) {
                                        const identityElem = remoteElem.getElementsByTagName('identity')[0];
                                        if (identityElem) {
                                            remoteParty = identityElem.textContent.trim();
                                        }
                                    }
                                    break;
                                } else if (state === 'trying' || state === 'proceeding') {
                                    callState = 'ringing';
                                    direction = directionAttr || 'unknown';
                                    break;
                                } else if (state === 'terminated') {
                                    // Skip terminated dialogs
                                    continue;
                                }
                            }
                        }
                    }

                    return {
                        aor: aor,
                        registered: registered,
                        callState: callState,
                        direction: direction,
                        remoteParty: remoteParty,
                        updatedAt: Date.now(),
                        source: 'dialog'
                    };

                } catch (error) {
                    this.log(`Error parsing dialog-info: ${error.message}`, 'error');
                    return null;
                }
            }

            parsePIDF(xmlBody, aor) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(xmlBody, 'text/xml');

                    if (doc.documentElement.nodeName === 'parsererror') {
                        this.log('Failed to parse PIDF XML', 'error');
                        return null;
                    }

                    const presence = doc.documentElement;
                    const tuples = presence.getElementsByTagName('tuple');

                    let basicStatus = 'closed';
                    let callState = 'unknown';
                    let registered = null;

                    if (tuples.length > 0) {
                        const tuple = tuples[0];
                        const statusElem = tuple.getElementsByTagName('status')[0];
                        if (statusElem) {
                            const basicElem = statusElem.getElementsByTagName('basic')[0];
                            if (basicElem) {
                                basicStatus = basicElem.textContent.trim().toLowerCase();
                                registered = basicStatus === 'open';
                            }
                        }
                    }

                    // Try to extract RPID activities
                    const personElems = presence.getElementsByTagNameNS('*', 'person');
                    if (personElems.length > 0) {
                        const activities = personElems[0].getElementsByTagNameNS('*', 'activities')[0];
                        if (activities) {
                            if (activities.getElementsByTagNameNS('*', 'on-the-phone').length > 0) {
                                callState = 'in_call';
                            } else if (activities.getElementsByTagNameNS('*', 'busy').length > 0) {
                                callState = 'busy';
                            } else if (activities.getElementsByTagNameNS('*', 'available').length > 0) {
                                callState = 'idle';
                            }
                        }
                    }

                    return {
                        aor: aor,
                        registered: registered,
                        callState: callState,
                        direction: 'unknown',
                        remoteParty: null,
                        updatedAt: Date.now(),
                        source: 'presence'
                    };

                } catch (error) {
                    this.log(`Error parsing PIDF: ${error.message}`, 'error');
                    return null;
                }
            }

            updatePresenceUI() {
                // Update subscription count
                const countElem = document.getElementById('subscriptionCount');
                if (countElem) {
                    countElem.textContent = this.activeSubscribers.size;
                }

                // Render presence list
                const listElem = document.getElementById('presenceList');
                if (!listElem) return;

                if (this.presenceStates.size === 0) {
                    listElem.innerHTML = '<div class="text-muted text-center">Presence information will appear here...</div>';
                    return;
                }

                let html = '<div class="row">';
                this.presenceStates.forEach((state, aor) => {
                    const extension = aor.split('@')[0].replace('sip:', '');

                    let statusBadge = 'secondary';
                    let statusText = state.callState;

                    if (state.callState === 'idle') {
                        statusBadge = 'success';
                        statusText = 'Available';
                    } else if (state.callState === 'in_call') {
                        statusBadge = 'danger';
                        statusText = 'On Call';
                    } else if (state.callState === 'ringing') {
                        statusBadge = 'warning';
                        statusText = 'Ringing';
                    } else if (state.callState === 'busy') {
                        statusBadge = 'danger';
                        statusText = 'Busy';
                    }

                    let directionIcon = '';
                    if (state.direction === 'initiator') {
                        directionIcon = '<i class="bi bi-arrow-up-circle text-primary"></i> ';
                    } else if (state.direction === 'recipient') {
                        directionIcon = '<i class="bi bi-arrow-down-circle text-success"></i> ';
                    }

                    const remoteInfo = state.remoteParty ? `<br><small class="text-muted">${state.remoteParty}</small>` : '';

                    html += `
                        <div class="col-md-4 col-lg-3 mb-2">
                            <div class="card presence-card">
                                <div class="card-body p-2">
                                    <div class="d-flex justify-content-between align-items-center">
                                        <strong>${extension}</strong>
                                        <span class="badge bg-${statusBadge}">${statusText}</span>
                                    </div>
                                    <div class="small text-muted mt-1">
                                        ${directionIcon}${state.source}${remoteInfo}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';

                listElem.innerHTML = html;

                // Sync with mobile presence list
                const listElemMobile = document.getElementById('presenceListMobile');
                if (listElemMobile) {
                    listElemMobile.innerHTML = html;
                }

                // Sync mobile subscription count
                const countElemMobile = document.getElementById('subscriptionCountMobile');
                if (countElemMobile) {
                    countElemMobile.textContent = this.activeSubscribers.size;
                }

                // Sync mobile presence status
                const myStatusMobile = document.getElementById('myPresenceStatusMobile');
                if (myStatusMobile) {
                    myStatusMobile.textContent = `${this.myPresenceState} (${this.myCallState})`;
                    myStatusMobile.className = 'badge ms-2 ' + (this.myPresenceState === 'open' ? 'bg-success' : 'bg-secondary');
                }
            }

            // ==================== New Features ====================

            // Account Info Methods
            updateAccountInfo() {
                const user = document.getElementById('sipUser').value || '-';
                const domain = document.getElementById('sipDomain').value || '-';
                document.getElementById('accountUser').textContent = user;
                document.getElementById('accountDomain').textContent = domain;
            }

            _extractExpiresFromResponse(response) {
                try {
                    const contactHeaders = response.message.getHeaders('contact');
                    if (contactHeaders && contactHeaders.length > 0) {
                        for (let i = 0; i < contactHeaders.length; i++) {
                            const contact = response.message.parseHeader('contact', i);
                            if (contact && contact.getParam && contact.getParam('expires')) {
                                const expires = Number(contact.getParam('expires'));
                                if (!isNaN(expires) && expires > 0) return expires;
                            }
                        }
                    }
                } catch (e) {
                    this.log(`Could not parse Contact expires: ${e.message}`, 'info');
                }

                try {
                    if (response.message.hasHeader('expires')) {
                        const expires = Number(response.message.getHeader('expires'));
                        if (!isNaN(expires) && expires > 0) return expires;
                    }
                } catch (e) {
                    this.log(`Could not parse Expires header: ${e.message}`, 'info');
                }

                return 600;
            }

            startRegExpiryCountdown(expires = 600) {
                this.registrationExpiry = Date.now() + (expires * 1000);

                if (this.regExpiryTimer) {
                    clearInterval(this.regExpiryTimer);
                }

                const expiryEl = document.getElementById('accountRegExpiry');
                this._updateExpiryDisplay(expiryEl, expires);

                this.regExpiryTimer = setInterval(() => {
                    const remaining = Math.max(0, Math.floor((this.registrationExpiry - Date.now()) / 1000));
                    this._updateExpiryDisplay(expiryEl, remaining);

                    if (remaining <= 0) {
                        clearInterval(this.regExpiryTimer);
                        expiryEl.textContent = 'Expired';
                        expiryEl.className = 'text-truncate ms-2 reg-expiry-danger';
                    }
                }, 1000);
            }

            _updateExpiryDisplay(element, remaining) {
                const minutes = Math.floor(remaining / 60);
                const seconds = remaining % 60;
                element.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                if (remaining <= this.regExpiryDangerThreshold) {
                    element.className = 'text-truncate ms-2 reg-expiry-danger';
                } else if (remaining <= this.regExpiryWarningThreshold) {
                    element.className = 'text-truncate ms-2 reg-expiry-warning';
                } else {
                    element.className = 'text-truncate ms-2 reg-expiry-normal';
                }
            }

            stopRegExpiryCountdown() {
                if (this.regExpiryTimer) {
                    clearInterval(this.regExpiryTimer);
                    this.regExpiryTimer = null;
                }
                const expiryEl = document.getElementById('accountRegExpiry');
                expiryEl.textContent = '-';
                expiryEl.className = 'text-truncate ms-2';
            }

            // DND Methods
            toggleDND(enabled) {
                this.isDND = enabled;
                const statusHeader = document.getElementById('statusHeader');
                const headerCallInfo = document.getElementById('headerCallInfo');

                if (enabled) {
                    this.log('Do Not Disturb enabled', 'info');
                    // Add DND badge to header
                    let dndBadge = document.getElementById('dndBadge');
                    if (!dndBadge) {
                        dndBadge = document.createElement('span');
                        dndBadge.id = 'dndBadge';
                        dndBadge.className = 'dnd-badge';
                        dndBadge.textContent = 'DND';
                        headerCallInfo.parentElement.insertBefore(dndBadge, headerCallInfo);
                    }
                } else {
                    this.log('Do Not Disturb disabled', 'info');
                    const dndBadge = document.getElementById('dndBadge');
                    if (dndBadge) dndBadge.remove();
                }

                this.saveSettings();
            }

            // Audio Device Methods
            async enumerateAudioDevices() {
                try {
                    // Request permission first
                    await navigator.mediaDevices.getUserMedia({ audio: true });

                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const micSelect = document.getElementById('micSelect');
                    const speakerSelect = document.getElementById('speakerSelect');

                    // Clear existing options
                    micSelect.innerHTML = '<option value="">Default</option>';
                    speakerSelect.innerHTML = '<option value="">Default</option>';

                    devices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label || `${device.kind} (${device.deviceId.slice(0, 8)}...)`;

                        if (device.kind === 'audioinput') {
                            micSelect.appendChild(option);
                        } else if (device.kind === 'audiooutput') {
                            speakerSelect.appendChild(option);
                        }
                    });

                    // Restore saved selections
                    if (this.selectedMicId) micSelect.value = this.selectedMicId;
                    if (this.selectedSpeakerId) speakerSelect.value = this.selectedSpeakerId;

                    this.log('Audio devices enumerated', 'success');
                } catch (error) {
                    this.log(`Failed to enumerate audio devices: ${error.message}`, 'error');
                }
            }

            applyAudioOutput() {
                const audio = document.getElementById('remoteAudio');
                if (audio && this.selectedSpeakerId && audio.setSinkId) {
                    audio.setSinkId(this.selectedSpeakerId).catch(err => {
                        this.log(`Failed to set audio output: ${err.message}`, 'error');
                    });
                }
            }

            // Quick Dial Methods
            loadQuickDials() {
                try {
                    const saved = localStorage.getItem('sipphone-jwt-quickdials');
                    if (saved) {
                        this.quickDials = JSON.parse(saved);
                        this.renderQuickDials();
                    }
                } catch (error) {
                    this.log(`Failed to load quick dials: ${error.message}`, 'error');
                }
            }

            saveQuickDials() {
                try {
                    localStorage.setItem('sipphone-jwt-quickdials', JSON.stringify(this.quickDials));
                } catch (error) {
                    this.log(`Failed to save quick dials: ${error.message}`, 'error');
                }
            }

            renderQuickDials() {
                const container = document.getElementById('quickDialList');

                if (this.quickDials.length === 0) {
                    container.innerHTML = '<div class="text-muted text-center small">No quick dials set</div>';
                    return;
                }

                let html = '';
                this.quickDials.forEach((qd, index) => {
                    html += `
                        <div class="quick-dial-item" data-number="${qd.number}">
                            <div>
                                <div class="dial-name">${qd.name}</div>
                                <div class="dial-number">${qd.number}</div>
                            </div>
                            <div class="dial-actions">
                                <button class="btn btn-sm btn-link btn-call p-0 me-1" onclick="event.stopPropagation(); softphone.dialQuickDial('${qd.number}')">
                                    <i class="bi bi-telephone-fill"></i>
                                </button>
                                <button class="btn btn-sm btn-link btn-remove p-0" onclick="event.stopPropagation(); softphone.removeQuickDial(${index})">
                                    <i class="bi bi-x"></i>
                                </button>
                            </div>
                        </div>
                    `;
                });
                container.innerHTML = html;

                // Add click handlers for dialing
                container.querySelectorAll('.quick-dial-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const number = item.dataset.number;
                        document.getElementById('phoneNumber').value = number;
                    });
                });
            }

            showAddQuickDialModal() {
                const name = prompt('Enter name for quick dial:');
                if (!name) return;

                const number = prompt('Enter phone number:');
                if (!number) return;

                this.quickDials.push({ name, number });
                this.saveQuickDials();
                this.renderQuickDials();
                this.log(`Quick dial added: ${name} - ${number}`, 'success');
            }

            removeQuickDial(index) {
                const removed = this.quickDials.splice(index, 1);
                this.saveQuickDials();
                this.renderQuickDials();
                this.log(`Quick dial removed: ${removed[0]?.name}`, 'info');
            }

            dialQuickDial(number) {
                document.getElementById('phoneNumber').value = number;
                this.makeCall();
            }

            // Favorites Methods
            loadFavorites() {
                try {
                    const saved = localStorage.getItem('sipphone-jwt-favorites');
                    if (saved) {
                        this.favorites = JSON.parse(saved);
                        this.renderFavorites();
                    }
                } catch (error) {
                    this.log(`Failed to load favorites: ${error.message}`, 'error');
                }
            }

            saveFavorites() {
                try {
                    localStorage.setItem('sipphone-jwt-favorites', JSON.stringify(this.favorites));
                } catch (error) {
                    this.log(`Failed to save favorites: ${error.message}`, 'error');
                }
            }

            renderFavorites() {
                const container = document.getElementById('favoritesList');

                if (this.favorites.length === 0) {
                    container.innerHTML = '<div class="text-muted text-center small">No favorites yet</div>';
                    return;
                }

                let html = '';
                this.favorites.forEach((fav, index) => {
                    html += `
                        <div class="favorite-item" data-number="${fav.number}">
                            <div>
                                <div class="fav-name"><i class="bi bi-star-fill text-warning me-1"></i>${fav.number}</div>
                            </div>
                            <div class="fav-actions">
                                <button class="btn btn-sm btn-link btn-call p-0 me-1" onclick="event.stopPropagation(); softphone.dialFavorite('${fav.number}')">
                                    <i class="bi bi-telephone-fill text-success"></i>
                                </button>
                                <button class="btn btn-sm btn-link btn-remove p-0" onclick="event.stopPropagation(); softphone.removeFavorite(${index})">
                                    <i class="bi bi-x"></i>
                                </button>
                            </div>
                        </div>
                    `;
                });
                container.innerHTML = html;

                // Add click handlers
                container.querySelectorAll('.favorite-item').forEach(item => {
                    item.addEventListener('click', () => {
                        document.getElementById('phoneNumber').value = item.dataset.number;
                    });
                });
            }

            addToFavorites(number) {
                if (this.favorites.find(f => f.number === number)) {
                    this.log(`${number} is already in favorites`, 'info');
                    return;
                }

                this.favorites.push({ number });
                this.saveFavorites();
                this.renderFavorites();
                this.renderCallHistory(); // Re-render to update star icons
                this.log(`Added ${number} to favorites`, 'success');
            }

            removeFavorite(index) {
                const removed = this.favorites.splice(index, 1);
                this.saveFavorites();
                this.renderFavorites();
                this.renderCallHistory(); // Re-render to update star icons
                this.log(`Removed ${removed[0]?.number} from favorites`, 'info');
            }

            dialFavorite(number) {
                document.getElementById('phoneNumber').value = number;
                this.makeCall();
            }

            isFavorite(number) {
                return this.favorites.some(f => f.number === number);
            }

            handleDisconnection(error) {
                this.log('Handling disconnection...', 'info');

                // Clean up presence subscriptions
                this.cleanupPresence();

                // Don't reconnect if this was an intentional disconnect
                if (this.isIntentionalDisconnect) {
                    this.log('Intentional disconnect - not attempting reconnection', 'info');
                    this.isIntentionalDisconnect = false;
                    return;
                }

                // Attempt reconnection with exponential backoff
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const backoffDelay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);

                    this.log(`Reconnecting in ${backoffDelay / 1000}s (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`, 'info');

                    this.reconnectTimer = setTimeout(() => {
                        this.log('Attempting reconnection...', 'info');
                        this.connect();
                    }, backoffDelay);
                } else {
                    this.log('Max reconnection attempts reached', 'error');
                    this.reconnectAttempts = 0;
                }
            }

            clearReconnectTimer() {
                if (this.reconnectTimer) {
                    clearTimeout(this.reconnectTimer);
                    this.reconnectTimer = null;
                }
            }
        }

        // Initialise the softphone when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.softphone = new SoftPhone();
        });
    </script>
</body>
</html>
